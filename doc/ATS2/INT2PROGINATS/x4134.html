<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>データ型からデータ観型への翻訳</TITLE
><META
CHARSET="UTF-8"><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="ATSプログラミング入門"
HREF="book1.html"><LINK
REL="UP"
TITLE="線形データ型としてのデータ観型 (dataviewtype)"
HREF="c3791.html"><LINK
REL="PREVIOUS"
TITLE="線形2分探索木"
HREF="x4080.html"><LINK
REL="NEXT"
TITLE="抽象観と観型 (viewtype)"
HREF="c4166.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="./assets/INT2PROGINATS-BOOK.css"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>ATSプログラミング入門: </TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x4080.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 15. 線形データ型としてのデータ観型 (dataviewtype)</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c4166.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="transition_from_datatypes_to_dataviewtypes"
>データ型からデータ観型への翻訳</A
></H1
><P
>&#13;多くのプログラマは、データ観型の値を操作するコードを書くことを幾分複雑に感じると思います。
込み入ったデータ構造を扱う時、しばしば私はデータ型をはじめに使おうとすることがあります。
そのデータ構造をモデリングして、データ型を用いてそのデータ構造のいくつかの機能を実装してみるのです。
それからそのデータ型を対応するデータ観型に変換し、データ観型として動作するようにその実装を修正します。
ここでは、以前の <A
HREF="x2807.html"
>implementation of functional red-black trees</A
> を元にした線形赤黒木の実装を次に示します。
これはデータ型からデータ観型への漸進的な翻訳を具体的に説明しています。
データ観型を直接用いてプログラミングしようとする際の難易度を大きく減少させることができるのです。

</P
><P
>&#13;次のデータ観型 <FONT
COLOR="RED"
>rbtree</FONT
> 宣言は以前のデータ型 <FONT
COLOR="RED"
>rbtree</FONT
> 宣言とほぼ一致しています。
違うのはキーワード <FONT
COLOR="RED"
>datatype</FONT
> の代わりに、キーワード <FONT
COLOR="RED"
>datavtype</FONT
> を使っている点です:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4143"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="neuexp"><span class="keyword">#define</span> BLK 0</span><span class="keyword">;</span> <span class="neuexp"><span class="keyword">#define</span> RED 1</span>
<span class="staexp"><span class="keyword">sortdef</span> clr <span class="keyword">=</span> <span class="keyword">{</span>c<span class="keyword">:</span>int <span class="keyword">|</span> 0 &lt;= c<span class="keyword">;</span> c &lt;= 1<span class="keyword">}</span></span>

<span class="keyword">datavtype</span> <span class="staexp">rbtree
<span class="keyword">(</span>
  a<span class="keyword">:</span> <span class="keyword">t@ype+</span><span class="keyword">,</span> int<span class="comment">(*c*)</span><span class="keyword">,</span> int<span class="comment">(*bh*)</span><span class="keyword">,</span> int<span class="comment">(*v*)</span>
<span class="keyword">)</span> <span class="keyword">=</span> <span class="comment">// element type, color, black height, violations</span>
  <span class="keyword">|</span> <span class="dynexp">rbtree_nil <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">BLK</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="dynexp"><span class="staexp"><span class="keyword">{</span>c<span class="keyword">,</span>cl<span class="keyword">,</span>cr<span class="keyword">:</span>clr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>bh<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>v<span class="keyword">:</span>int<span class="keyword">}</span></span>
    <span class="staexp"><span class="keyword">{</span>c==BLK &amp;&amp; v==0 || c == RED &amp;&amp; v==cl+cr<span class="keyword">}</span></span>
    rbtree_cons <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="staexp">+</span><span class="staexp">1</span><span class="staexp">-</span><span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">v</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">int</span> <span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">rbtree0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">cl</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">rbtree0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">cr</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">)</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [rbtree]</span>

<span class="keyword">where</span> <span class="staexp">rbtree0 <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span><span class="keyword">t@ype</span></span><span class="keyword">,</span> <span class="staexp">c<span class="keyword">:</span>int</span><span class="keyword">,</span> <span class="staexp">bh<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">rbtree</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;ひと目見たところ、次の関数テンプレート <FONT
COLOR="RED"
>insfix_l</FONT
> は (関数的な赤黒木の)
同じ名前の関数よりもはるかに複雑です:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4147"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> insfix_l <span class="comment">// right rotation</span>
  <span class="staexp"><span class="keyword">{</span>cl<span class="keyword">,</span>cr<span class="keyword">:</span>clr<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>bh<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>v<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">,</span>l_c<span class="keyword">,</span>l_tl<span class="keyword">,</span>l_x<span class="keyword">,</span>l_tr<span class="keyword">:</span>addr<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf_c<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">(</span><span class="staexp">BLK</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l_c</span></span>
<span class="keyword">,</span> <span class="prfexp">pf_tl<span class="keyword">:</span> <span class="staexp">rbtree</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">cl</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">,</span> <span class="staexp">v</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l_tl</span></span>
<span class="keyword">,</span> <span class="prfexp">pf_x<span class="keyword">:</span> <span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l_x</span></span>
<span class="keyword">,</span> <span class="prfexp">pf_tr<span class="keyword">:</span> <span class="staexp">rbtree</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">cr</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l_tr</span></span>
<span class="keyword">|</span> t<span class="keyword">:</span> <span class="staexp">rbtree_cons_unfold</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">l_c</span><span class="keyword">,</span> <span class="staexp">l_tl</span><span class="keyword">,</span> <span class="staexp">l_x</span><span class="keyword">,</span> <span class="staexp">l_tr</span><span class="keyword">)</span>
<span class="keyword">,</span> p_tl<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l_tl</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>c<span class="keyword">:</span>clr<span class="keyword">]</span></span> <span class="staexp">rbtree0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="neuexp"><span class="keyword">#define</span> B BLK</span>
  <span class="neuexp"><span class="keyword">#define</span> R RED</span>
  <span class="neuexp"><span class="keyword">#define</span> nil rbtree_nil</span>
  <span class="neuexp"><span class="keyword">#define</span> cons rbtree_cons</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> <span class="keyword">!</span>p_tl <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">@</span>cons <span class="keyword">(</span><span class="staexp">cl</span> <span class="keyword">as</span> R<span class="keyword">,</span> <span class="staexp">tll</span> <span class="keyword">as</span> <span class="keyword">@</span>cons <span class="keyword">(</span><span class="staexp">cll</span> <span class="keyword">as</span> R<span class="keyword">,</span> _<span class="keyword">,</span> _<span class="keyword">,</span> _<span class="keyword">)</span><span class="keyword">,</span> _<span class="keyword">,</span> tlr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
<span class="comment">//</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> cll := B</span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>tll<span class="keyword">)</span></span>
<span class="comment">//</span>
      <span class="dynexp"><span class="keyword">val</span> tl <span class="keyword">=</span> <span class="keyword">!</span>p_tl</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>p_tl := tlr</span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>t<span class="keyword">)</span></span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> tlr := t</span>
<span class="comment">//</span>
    <span class="keyword">in</span>
      <span class="keyword">fold@</span> <span class="keyword">(</span>tl<span class="keyword">)</span><span class="keyword">;</span> tl
    <span class="keyword">end</span> <span class="comment">// end of [cons (R, cons (R, ...), ...)]</span>
  <span class="keyword">|</span> <span class="keyword">@</span>cons <span class="keyword">(</span><span class="staexp">cl</span> <span class="keyword">as</span> R<span class="keyword">,</span> tll<span class="keyword">,</span> _<span class="keyword">,</span> <span class="staexp">tlr</span> <span class="keyword">as</span> <span class="keyword">@</span>cons <span class="keyword">(</span><span class="staexp">clr</span> <span class="keyword">as</span> R<span class="keyword">,</span> tlrl<span class="keyword">,</span> _<span class="keyword">,</span> tlrr<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
<span class="comment">//</span>
      <span class="dynexp"><span class="keyword">val</span> tl <span class="keyword">=</span> <span class="keyword">!</span>p_tl</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>p_tl := tlrr</span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>t<span class="keyword">)</span></span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> tlrr := t</span>
<span class="comment">//</span>
      <span class="dynexp"><span class="keyword">val</span> tlr_ <span class="keyword">=</span> tlr</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> tlr := tlrl</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> cl := B</span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>tl<span class="keyword">)</span></span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> tlrl := tl</span>
<span class="comment">//</span>
    <span class="keyword">in</span>
      <span class="keyword">fold@</span> <span class="keyword">(</span>tlr_<span class="keyword">)</span><span class="keyword">;</span> tlr_
    <span class="keyword">end</span> <span class="comment">// end of [cons (R, ..., cons (R, ...))]</span>
  <span class="keyword">|</span> _ <span class="comment">(*rest-of-cases*)</span> <span class="keyword">=&gt;&gt;</span> <span class="keyword">(</span><span class="keyword">fold@</span> <span class="keyword">(</span>t<span class="keyword">)</span><span class="keyword">;</span> t<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [insfix_l]</span>
</p></PRE
><P
></P
></DIV
>


けれども、上記の <FONT
COLOR="RED"
>insfix_l</FONT
> のインターフェイスは以前示した <FONT
COLOR="RED"
>infix_l</FONT
> のインターフェイスを
<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>直接</I
></SPAN
> 翻訳したものだと指摘したいのです。
別の言い方をすると、以前の実装は回転される木と <FONT
COLOR="RED"
>infix_l</FONT
>
をそれに適用して得られる木との関係を捕捉していました。
これはまた線形赤黒木でも維持されています。
次の関数テンプレート <FONT
COLOR="RED"
>insfix_r</FONT
> のようによく似た文を作ることができます。
これは <FONT
COLOR="RED"
>insfix_l</FONT
> の正確な鏡像になっています:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4155"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="dynexp"><span class="keyword">fn</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> insfix_r <span class="comment">// left rotation</span>
  <span class="staexp"><span class="keyword">{</span>cl<span class="keyword">,</span>cr<span class="keyword">:</span>clr<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>bh<span class="keyword">:</span>nat<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>v<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">,</span>l_c<span class="keyword">,</span>l_tl<span class="keyword">,</span>l_x<span class="keyword">,</span>l_tr<span class="keyword">:</span>addr<span class="keyword">}</span></span> <span class="keyword">(</span>
  <span class="prfexp">pf_c<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">(</span><span class="staexp">BLK</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l_c</span></span>
<span class="keyword">,</span> <span class="prfexp">pf_tl<span class="keyword">:</span> <span class="staexp">rbtree</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">cl</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l_tl</span></span>
<span class="keyword">,</span> <span class="prfexp">pf_x<span class="keyword">:</span> <span class="staexp">a</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l_x</span></span>
<span class="keyword">,</span> <span class="prfexp">pf_tr<span class="keyword">:</span> <span class="staexp">rbtree</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">cr</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">,</span> <span class="staexp">v</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l_tr</span></span>
<span class="keyword">|</span> t<span class="keyword">:</span> <span class="staexp">rbtree_cons_unfold</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">l_c</span><span class="keyword">,</span> <span class="staexp">l_tl</span><span class="keyword">,</span> <span class="staexp">l_x</span><span class="keyword">,</span> <span class="staexp">l_tr</span><span class="keyword">)</span>
<span class="keyword">,</span> p_tr<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l_tr</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>c<span class="keyword">:</span>clr<span class="keyword">]</span></span> <span class="staexp">rbtree0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="neuexp"><span class="keyword">#define</span> B BLK</span>
  <span class="neuexp"><span class="keyword">#define</span> R RED</span>
  <span class="neuexp"><span class="keyword">#define</span> nil rbtree_nil</span>
  <span class="neuexp"><span class="keyword">#define</span> cons rbtree_cons</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> <span class="keyword">!</span>p_tr <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">@</span>cons <span class="keyword">(</span><span class="staexp">cr</span> <span class="keyword">as</span> R<span class="keyword">,</span> trl<span class="keyword">,</span> _<span class="keyword">,</span> <span class="staexp">trr</span> <span class="keyword">as</span> <span class="keyword">@</span>cons <span class="keyword">(</span><span class="staexp">crr</span> <span class="keyword">as</span> R<span class="keyword">,</span> _<span class="keyword">,</span> _<span class="keyword">,</span> _<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
<span class="comment">//</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> crr := B</span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>trr<span class="keyword">)</span></span>
<span class="comment">//</span>
      <span class="dynexp"><span class="keyword">val</span> tr <span class="keyword">=</span> <span class="keyword">!</span>p_tr</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>p_tr := trl</span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>t<span class="keyword">)</span></span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> trl := t</span>
<span class="comment">//</span>
    <span class="keyword">in</span>
      <span class="keyword">fold@</span> <span class="keyword">(</span>tr<span class="keyword">)</span><span class="keyword">;</span> tr
    <span class="keyword">end</span> <span class="comment">// end of [cons (R, ..., cons (R, ...))]</span>
  <span class="keyword">|</span> <span class="keyword">@</span>cons <span class="keyword">(</span><span class="staexp">cr</span> <span class="keyword">as</span> R<span class="keyword">,</span> <span class="staexp">trl</span> <span class="keyword">as</span> <span class="keyword">@</span>cons <span class="keyword">(</span><span class="staexp">crr</span> <span class="keyword">as</span> R<span class="keyword">,</span> trll<span class="keyword">,</span> _<span class="keyword">,</span> trlr<span class="keyword">)</span><span class="keyword">,</span> _<span class="keyword">,</span> trr<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
<span class="comment">//</span>
      <span class="dynexp"><span class="keyword">val</span> tr <span class="keyword">=</span> <span class="keyword">!</span>p_tr</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">!</span>p_tr := trll</span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>t<span class="keyword">)</span></span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> trll := t</span>
<span class="comment">//</span>
      <span class="dynexp"><span class="keyword">val</span> trl_ <span class="keyword">=</span> trl</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> trl := trlr</span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> cr := B</span>
      <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>tr<span class="keyword">)</span></span>
      <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> trlr := tr</span>
<span class="comment">//</span>
    <span class="keyword">in</span>
      <span class="keyword">fold@</span> <span class="keyword">(</span>trl_<span class="keyword">)</span><span class="keyword">;</span> trl_
    <span class="keyword">end</span> <span class="comment">// end of [cons (R, cons (R, ...), ...)]</span>
  <span class="keyword">|</span> _ <span class="comment">(*rest-of-cases*)</span> <span class="keyword">=&gt;&gt;</span> <span class="keyword">(</span><span class="keyword">fold@</span> <span class="keyword">(</span>t<span class="keyword">)</span><span class="keyword">;</span> t<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [insfix_r]</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;予想されることですが、本質的に次の関数テンプレート <FONT
COLOR="RED"
>rbtree_insert</FONT
>
は、関数的な赤黒木に要素を挿入する同じ名前の実装の直接的な翻訳です:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4159"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
rbtree_insert
  <span class="staexp"><span class="keyword">{</span>c<span class="keyword">:</span>clr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>bh<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  t<span class="keyword">:</span> <span class="staexp">rbtree0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">)</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmp</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>bh1<span class="keyword">:</span>nat<span class="keyword">]</span></span> <span class="staexp">rbtree0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">BLK</span><span class="keyword">,</span> <span class="staexp">bh1</span><span class="keyword">)</span></span>

<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
rbtree_insert
  <span class="keyword">(</span>t<span class="keyword">,</span> x0<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span> B BLK</span>
<span class="neuexp"><span class="keyword">#define</span> R RED</span>
<span class="neuexp"><span class="keyword">#define</span> nil rbtree_nil</span>
<span class="neuexp"><span class="keyword">#define</span> cons rbtree_cons</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> ins
  <span class="staexp"><span class="keyword">{</span>c<span class="keyword">:</span>clr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>bh<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">.&lt;</span><span class="staexp">bh</span><span class="keyword">,</span><span class="staexp">c</span><span class="keyword">&gt;.</span>
<span class="keyword">(</span>
  t<span class="keyword">:</span> <span class="staexp">rbtree0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">)</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>cl<span class="keyword">:</span>clr<span class="keyword">;</span> v<span class="keyword">:</span>nat <span class="keyword">|</span> v &lt;= c<span class="keyword">]</span></span> <span class="staexp">rbtree</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">cl</span><span class="keyword">,</span> <span class="staexp">bh</span><span class="keyword">,</span> <span class="staexp">v</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
  <span class="keyword">case+</span> t <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">@</span>cons <span class="keyword">(</span>
      c<span class="keyword">,</span> tl<span class="keyword">,</span> x<span class="keyword">,</span> tr
    <span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="prfexp"><span class="keyword">prval</span> pf_c <span class="keyword">=</span> <span class="dynexp"><span class="keyword">view@</span></span>c</span>
      <span class="prfexp"><span class="keyword">prval</span> pf_tl <span class="keyword">=</span> <span class="dynexp"><span class="keyword">view@</span></span>tl</span>
      <span class="prfexp"><span class="keyword">prval</span> pf_x <span class="keyword">=</span> <span class="dynexp"><span class="keyword">view@</span></span>x</span>
      <span class="prfexp"><span class="keyword">prval</span> pf_tr <span class="keyword">=</span> <span class="dynexp"><span class="keyword">view@</span></span>tr</span>
      <span class="dynexp"><span class="keyword">val</span> sgn <span class="keyword">=</span> compare&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x0<span class="keyword">,</span> x<span class="keyword">,</span> cmp<span class="keyword">)</span></span>
    <span class="keyword">in</span>
      <span class="keyword">if</span> sgn <span class="keyword">&lt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
        <span class="dynexp"><span class="keyword">val</span> <span class="keyword">[</span><span class="staexp">cl<span class="keyword">:</span>int</span><span class="keyword">,</span><span class="staexp">v<span class="keyword">:</span>int</span><span class="keyword">]</span> tl_ <span class="keyword">=</span> ins <span class="keyword">(</span>tl<span class="keyword">,</span> x0<span class="keyword">)</span></span>
        <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> tl := tl_</span>
      <span class="keyword">in</span>
        <span class="keyword">if</span> <span class="keyword">(</span>c <span class="keyword">=</span> B<span class="keyword">)</span>
        <span class="keyword">then</span> <span class="keyword">(</span>
          insfix_l&lt;<span class="staexp">a</span><span class="keyword">&gt;</span>
            <span class="keyword">(</span><span class="prfexp">pf_c</span><span class="keyword">,</span> <span class="prfexp">pf_tl</span><span class="keyword">,</span> <span class="prfexp">pf_x</span><span class="keyword">,</span> <span class="prfexp">pf_tr</span> <span class="keyword">|</span> t<span class="keyword">,</span> <span class="dynexp"><span class="keyword">addr@</span></span>tl<span class="keyword">)</span>
          <span class="comment">// end of [insfix_l]</span>
        <span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">let</span>
          <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> c := R</span> <span class="keyword">in</span> <span class="keyword">fold@</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>cl<span class="keyword">}</span></span><span class="keyword">(</span>t<span class="keyword">)</span><span class="keyword">;</span> t
        <span class="keyword">end</span> <span class="comment">// end of [if]</span>
      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> sgn <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
        <span class="dynexp"><span class="keyword">val</span> <span class="keyword">[</span><span class="staexp">cr<span class="keyword">:</span>int</span><span class="keyword">,</span><span class="staexp">v<span class="keyword">:</span>int</span><span class="keyword">]</span> tr_ <span class="keyword">=</span> ins <span class="keyword">(</span>tr<span class="keyword">,</span> x0<span class="keyword">)</span></span>
        <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> tr := tr_</span>
      <span class="keyword">in</span>
        <span class="keyword">if</span> <span class="keyword">(</span>c <span class="keyword">=</span> B<span class="keyword">)</span>
        <span class="keyword">then</span> <span class="keyword">(</span>
          insfix_r&lt;<span class="staexp">a</span><span class="keyword">&gt;</span>
            <span class="keyword">(</span><span class="prfexp">pf_c</span><span class="keyword">,</span> <span class="prfexp">pf_tl</span><span class="keyword">,</span> <span class="prfexp">pf_x</span><span class="keyword">,</span> <span class="prfexp">pf_tr</span> <span class="keyword">|</span> t<span class="keyword">,</span> <span class="dynexp"><span class="keyword">addr@</span></span>tr<span class="keyword">)</span>
          <span class="comment">// end of [insfix_r]</span>
        <span class="keyword">)</span> <span class="keyword">else</span> <span class="keyword">let</span>
          <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> c := R</span> <span class="keyword">in</span> <span class="keyword">fold@</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>cr<span class="keyword">}</span></span><span class="keyword">(</span>t<span class="keyword">)</span><span class="keyword">;</span> t
        <span class="keyword">end</span> <span class="comment">// end of [if]</span>
      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">fold@</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>0<span class="keyword">}</span></span> <span class="keyword">(</span>t<span class="keyword">)</span><span class="keyword">;</span> t<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [cons]</span>
  <span class="keyword">|</span> <span class="keyword">~</span>nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> cons<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>0<span class="keyword">}</span></span><span class="keyword">(</span>R<span class="keyword">,</span> nil<span class="keyword">,</span> x0<span class="keyword">,</span> nil<span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [ins] *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> t <span class="keyword">=</span> ins <span class="keyword">(</span>t<span class="keyword">,</span> x0<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">case+</span> t <span class="keyword">of</span> <span class="keyword">@</span>cons<span class="keyword">(</span><span class="staexp">c</span> <span class="keyword">as</span> R<span class="keyword">,</span> _<span class="keyword">,</span> _<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>c := B<span class="keyword">;</span> <span class="keyword">fold@</span> <span class="keyword">(</span>t<span class="keyword">)</span><span class="keyword">;</span> t<span class="keyword">)</span> <span class="keyword">|</span> _ <span class="keyword">=&gt;&gt;</span> t
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [rbtree_insert]</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;私は文字通り以前の関数的な赤黒木の <FONT
COLOR="RED"
>rbtree_insert</FONT
>
実装をコピーし、それから型検査を通るように適切に修正して、上記の <FONT
COLOR="RED"
>rbtree_insert</FONT
> を実装しました。
このコピーして修正する作業は外見的には難しく見えますが、型検査して起きるエラーメッセージに従えばそのほとんどはかなり単純です。

</P
><P
>&#13;この章のコード全体と追加のテストコードは
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_DATAVTYPE/rbtree.dats"
TARGET="_top"
>オンライン</A
>
から入手できます。
与えられた線形赤黒木から要素を削除する操作を実装することは、読者にとってやりがいのある練習問題でしょう。

</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x4080.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c4166.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>線形2分探索木</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c3791.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>抽象観と観型 (viewtype)</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>