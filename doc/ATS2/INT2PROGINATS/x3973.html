<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>線形2分探索木</TITLE
><META
CHARSET="UTF-8"><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="ATSプログラミング入門"
HREF="index.html"><LINK
REL="UP"
TITLE="線形 datatype としての dataviewtype"
HREF="c3684.html"><LINK
REL="PREVIOUS"
TITLE="例: 線形リストのクイックソート"
HREF="x3936.html"><LINK
REL="NEXT"
TITLE="datatype から dataviewtype への翻訳"
HREF="x4027.html"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>ATSプログラミング入門: </TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x3936.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 15. 線形 datatype としての dataviewtype</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x4027.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="linear_binary_search_trees"
>15.6. 線形2分探索木</A
></H1
><P
>&#13;与えられた順序に対する2分探索木は二分木です。
この木の中のそれぞれのノードに保管されている値は、そのノードの左の子以上でかつ右の子以下になっています。
2分探索木は連想配列を実装するのに一般的なデータ構造です。

</P
><P
>&#13;二分木の最長と最短の高さの比がどの木においても定数 C の範囲におさまるとき、この二分木は平衡木であると呼ばれます。
例えば、平衡2分探索木の一般的な例としてはAVL木や赤黒木があります。
平衡2分探索木を用いた連想配列は log 時間で挿入/削除操作ができることを保証します。
すなわち、n が連想配列のサイズであるとき、そのような操作を完了するのにかかる時間は最悪でも O(log(n))
になります。

</P
><P
>&#13;この章では、線形2分探索木に対するいくつかの基本的な操作を実装します。
さらにその後 dataviewtype を使った実装を紹介します。
はじめに、線形2分探索木のために次の dataviewtype <FONT
COLOR="RED"
>bstree_vt</FONT
> を宣言しましょう:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3979"
></A
><PRE
CLASS="programlisting"
>datavtype
bstree_vt (a:t@ype+, int) =
  | bstree_vt_nil (a, 0) of ()
  | {n1,n2:nat}
    bstree_vt_cons (a, n1+n2+1) of (bstree_vt (a, n1), a, bstree_vt (a, n2))
// end of [bstree_vt]
</PRE
><P
></P
></DIV
>


</P
><P
>&#13;<FONT
COLOR="RED"
>bstree_vt</FONT
> の整数インデックスは、2分探索木のサイズ情報を捕捉していることに注意してください。
<FONT
COLOR="RED"
>bstree_vt</FONT
> に関連する2つのコンストラクタ <FONT
COLOR="RED"
>bstree_vt_cons</FONT
> と <FONT
COLOR="RED"
>bstree_vt_nil</FONT
>
があります。
<FONT
COLOR="RED"
>bstree_vt_nil</FONT
> によって生成された木は空で葉を持たず、他方ではノードは左と右の子が両方とも空であることは指摘すべきでしょう。
簡単な例として、次の関数テンプレート <FONT
COLOR="RED"
>size</FONT
> は与えられた木のサイズを計算します:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3988"
></A
><PRE
CLASS="programlisting"
>fun{
a:t@ype
} size{n:nat} .&#60;n&#62;.
(
  t: !bstree_vt (a, n)
) : int (n) =
  case+ t of
  | bstree_vt_nil () =&#62; 0
  | bstree_vt_cons
     (tl, _, tr) =&#62; 1 + size (tl) + size (tr)
// end of [size]
</PRE
><P
></P
></DIV
>


</P
><P
>&#13;なんらかの順序による2分探索木を持っていると仮定します。
もし木に保管されている要素について x1 が x2 より (順序によると) 小さいなら P(x1) が P(x2)
を含むような性質を持つ述語 P があるとすると、次の <FONT
COLOR="RED"
>search</FONT
>
の実装によって示されるような2分探索によって呼び出される述語 P を満たす木の最小の要素の場所を見つけることができます:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3992"
></A
><PRE
CLASS="programlisting"
>fun{
a:t@ype
} search
  {n:nat} .&#60;n&#62;.
(
  t: !bstree_vt (a, n), P: (&#38;a) -&#60;cloref&#62; bool
) : Option_vt (a) =
  case+ t of
  | @bstree_vt_cons
      (tl, x, tr) =&#62;
      if P (x) then let
        val res = search (tl, P)
        val res = (
          case+ res of
          | ~None_vt () =&#62; Some_vt (x) | _ =&#62; res
        ) : Option_vt (a)
      in
        fold@ (t); res
      end else let
        val res = search (tr, P) in fold@ (t); res
      end // end of [if]
  | @bstree_vt_nil () =&#62; (fold@ (t); None_vt ())
// end of [search]
</PRE
><P
></P
></DIV
>


もし <FONT
COLOR="RED"
>search</FONT
> の引数 <FONT
COLOR="RED"
>t</FONT
> が平衡木の一種であるなら、<FONT
COLOR="RED"
>P</FONT
> の時間的計算量が O(1)
であると仮定すると <FONT
COLOR="RED"
>search</FONT
> の計算量は O(log(n)) であることは明確です。

</P
><P
>&#13;次に、与えられた要素を2分探索木に挿入する操作を実装してみましょう:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3999"
></A
><PRE
CLASS="programlisting"
>fun{
a:t@ype
} insert{n:nat} .&#60;n&#62;.
(
  t: bstree_vt (a, n), x0: &#38;a, cmp: cmp(a)
) : bstree_vt (a, n+1) =
  case+ t of
  | @bstree_vt_cons
      (tl, x, tr) =&#62; let
      val sgn = compare&#60;a&#62; (x0, x, cmp)
    in
      if sgn &#60;= 0 then let
        val () = tl := insert (tl, x0, cmp)
      in
        fold@ (t); t
      end else let
        val () = tr := insert (tr, x0, cmp)
      in
        fold@ (t); t
      end (* end of [if] *)
    end // end of [bstree_vt_cons]
  | ~bstree_vt_nil () =&#62;
      bstree_vt_cons (bstree_vt_nil, x0, bstree_vt_nil)
    // end of [bstree_vt_nil]
// end of [insert]
</PRE
><P
></P
></DIV
>


</P
><P
>&#13;要素を挿入する時、関数テンプレート <FONT
COLOR="RED"
>insert</FONT
> はその要素を含む新しい葉で与えられた木を拡張します。
このような挿入方法はしばしば leaf-insertion と呼ばれます。
別の挿入方法として root-insertion
としばしば呼ばれる方法があり、これは挿入された要素を含む新しいノードをルートに置きます。
次の関数テンプレート <FONT
COLOR="RED"
>insertRT</FONT
> は一般的な root-insertion 操作を実装しています:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4004"
></A
><PRE
CLASS="programlisting"
>fun{
a:t@ype
} insertRT{n:nat} .&#60;n&#62;.
(
  t: bstree_vt (a, n), x0: &#38;a, cmp: cmp(a)
) : bstree_vt (a, n+1) =
  case+ t of
  | @bstree_vt_cons
      (tl, x, tr) =&#62; let
      val sgn = compare&#60;a&#62; (x0, x, cmp)
    in
      if sgn &#60;= 0 then let
        val tl_ = insertRT (tl, x0, cmp)
        val+@bstree_vt_cons (_, tll, tlr) = tl_
        val () = tl := tlr
        prval () = fold@ (t)
        val () = tlr := t
      in
        fold@ (tl_); tl_
      end else let
        val tr_ = insertRT (tr, x0, cmp)
        val+@bstree_vt_cons (trl, _, trr) = tr_
        val () = tr := trl
        prval () = fold@ (t)
        val () = trl := t
      in
        fold@ (tr_); tr_
      end
    end // end of [bstree_vt_cons]
  | ~bstree_vt_nil () =&#62;
      bstree_vt_cons (bstree_vt_nil, x0, bstree_vt_nil)
    // end of [bstree_vt_nil]
// end of [insertRT]
</PRE
><P
></P
></DIV
>


1番目の再帰呼び出し <FONT
COLOR="RED"
>insertRT</FONT
> の直後のコードは木の右回転を行ないます。
ルートノードが要素 x とその左と右の子としてそれぞれ tl と tr を持つような木として T(tl, x, tr)
を用いることにしましょう。
すると T(T(tll, xl, tlr), x, tr) は右回転をすると T(tll, xl, T(tlr, x, tr)) になります。
2番目の再帰呼び出し <FONT
COLOR="RED"
>insertRT</FONT
> の直後のコードは木の左回転を行ないます。
すると T(tl, x, T(trl, xr, trr)) は T(T(tl, x, tlr), xr, trr) になります。

</P
><P
>&#13;さらに木の操作を説明するために、次の2つの関数テンプレート <FONT
COLOR="RED"
>lrotate</FONT
> と <FONT
COLOR="RED"
>rrotate</FONT
> を示します。
これらはそれぞれ木の左回転と右回転を実装しています:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4011"
></A
><PRE
CLASS="programlisting"
>fn{
a:t@ype
} lrotate
  {l,l_tl,l_x,l_tr:addr} 
  {nl,nr:int | nl &#62;= 0; nr &#62; 0}
(
  pf_tl: bstree_vt (a, nl) @ l_tl
, pf_x: a @ l_x
, pf_tr: bstree_vt (a, nr) @ l_tr
| t: bstree_vt_cons_unfold (l, l_tl, l_x, l_tr)
, p_tl: ptr l_tl
, p_tr: ptr l_tr
) : bstree_vt (a, 1+nl+nr) = let
  val tr = !p_tr
  val+@bstree_vt_cons (trl, _, trr) = tr
  val () = !p_tr := trl
  prval () = fold@ (t); val () = trl := t
in
  fold@ (tr); tr
end // end of [lrotate]

fn{
a:t@ype
} rrotate
  {l,l_tl,l_x,l_tr:addr}
  {nl,nr:int | nl &#62; 0; nr &#62;= 0}
(
  pf_tl: bstree_vt (a, nl) @ l_tl
, pf_x: a @ l_x
, pf_tr: bstree_vt (a, nr) @ l_tr
| t: bstree_vt_cons_unfold (l, l_tl, l_x, l_tr)
, p_tl: ptr l_tl
, p_tr: ptr l_tr
) : bstree_vt (a, 1+nl+nr) = let
  val tl = !p_tl
  val+@bstree_vt_cons (tll, x, tlr) = tl
  val () = !p_tl := tlr
  prval () = fold@ (t); val () = tlr := t
in
  fold@ (tl); tl
end // end of [rrotate]
</PRE
><P
></P
></DIV
>


4つのアドレス L0, L1, L2, L3 が与えられた時、型 <FONT
COLOR="RED"
>bstree_vt_cons_unfold(L0, L1, L2, l3)</FONT
>
は <FONT
COLOR="RED"
>bstree_vt_cons</FONT
> 呼び出しによって生成された木のノードを表わします。
このとき、そのノードは L0 に配置され、<FONT
COLOR="RED"
>bstree_vt_cons</FONT
> の3つの引数は L1, L2, L3 に配置されます。
そして L1, L2, L3 に関連する at-view の証明が現在有効な証明として保管されます。

</P
><P
>&#13;これで、root-insertion を行なう関数テンプレート <FONT
COLOR="RED"
>insertRT</FONT
> は
<FONT
COLOR="RED"
>lrotate</FONT
> と <FONT
COLOR="RED"
>rrotate</FONT
> を直接使って次のように実装できます:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4020"
></A
><PRE
CLASS="programlisting"
>fun{
a:t@ype
} insertRT {n:nat} .&#60;n&#62;.
(
  t: bstree_vt (a, n), x0: &#38;a, cmp: cmp(a)
) : bstree_vt (a, n+1) =
  case+ t of
  | @bstree_vt_cons
      (tl, x, tr) =&#62; let
      prval pf_x = view@x
      prval pf_tl = view@tl
      prval pf_tr = view@tr
      val sgn = compare&#60;a&#62; (x0, x, cmp)
    in
      if sgn &#60;= 0 then let
        val () = tl := insertRT&#60;a&#62; (tl, x0, cmp)
      in
        rrotate&#60;a&#62; (pf_tl, pf_x, pf_tr | t, addr@tl, addr@tr)
      end else let
        val () = tr := insertRT&#60;a&#62; (tr, x0, cmp)
      in
        lrotate&#60;a&#62; (pf_tl, pf_x, pf_tr | t, addr@tl, addr@tr)
      end (* end of [if] *)
    end // end of [bstree_vt_cons]
  | ~bstree_vt_nil () =&#62;
      bstree_vt_cons (bstree_vt_nil, x0, bstree_vt_nil)
    // end of [bstree_vt_nil]
// end of [insertRT]
</PRE
><P
></P
></DIV
>


</P
><P
>&#13;<FONT
COLOR="RED"
>insert</FONT
> も <FONT
COLOR="RED"
>insertRT</FONT
> も末尾再帰ではないことを指摘したいと思います。
前者を末尾再帰実装にすることはできますが、後者について同じことをする直接的な方法はありません。
root-insertion を末尾再帰的に実装するためには、親ポインタのある二分木が必要になります
(すなわちそれぞれのノードからその親に直接アクセスできるということです)。
これは dataview で実現できますが、dataviewtype を使って実現することはできません。

</P
><P
>&#13;この章のコード全体と追加のテストコードは
<A
HREF="http://www.ats-lang.org/DOCUMENT/INT2PROGINATS/CODE/CHAP_DATAVTYPE/bstree_vt.dats"
TARGET="_top"
>オンライン</A
>
から入手できます。

</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x3936.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x4027.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>例: 線形リストのクイックソート</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c3684.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>datatype から dataviewtype への翻訳</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>