<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>例: ブラウンツリーの性質を確立する</TITLE
><META
CHARSET="UTF-8"><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="ATSプログラミング入門"
HREF="book1.html"><LINK
REL="UP"
TITLE="ATS/LF を使った定理証明"
HREF="c2842.html"><LINK
REL="PREVIOUS"
TITLE="代数的なデータ種 (datasort)"
HREF="x2990.html"><LINK
REL="NEXT"
TITLE="プログラマ中心の定理証明"
HREF="x3073.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="./assets/INT2PROGINATS-BOOK.css"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>ATSプログラミング入門: </TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x2990.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 11. ATS/LF を使った定理証明</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x3073.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="example_establishing_properties_on_braun_trees"
>例: ブラウンツリーの性質を確立する</A
></H1
><P
>&#13;この本で以前示したように、空であるか、もしくは左と右の子がブラウンツリーでなおかつ左の子のサイズから右の子のサイズを引くと0もしくは1なら、そのような二分木はブラウンツリーです。
形式的には、ブラウンツリーの概念を捕捉するために、次のデータ命題 <FONT
COLOR="RED"
>isBraun</FONT
> を宣言できます:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3037"
></A
><PRE
CLASS="programlisting"
>dataprop isBraun (tree) =
  | isBraunE (E) of ()
  | {tl,tr:tree}
    {sl,sr:nat | sr &#60;= sl; sl &#60;= sr + 1}
    isBraunB (
      B(tl, tr)) of (isBraun tl, isBraun tr, SZ (tl, sl), SZ (tr, sr)
    ) // end of [isBraunB]
// end of [isBraun]
</PRE
><P
></P
></DIV
>

</P
><P
>与えられたどんなサイズのブラウンツリーも存在することをはじめに証明しましょう。
この性質は ATS では次のようにエンコードできます:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3040"
></A
><PRE
CLASS="programlisting"
>extern
prfun lemma_existence {n:nat} (): [t:tree] (isBraun (t), SZ (t, n))
</PRE
><P
></P
></DIV
>


事実上、<FONT
COLOR="RED"
>lemma_existence</FONT
> に割り当てられた型は
t がブラウンツリーで t のサイズが n であるような自然数 n が与えられた時、木 t が存在することを意味しています。
次のコードは <FONT
COLOR="RED"
>lemma_existence</FONT
> の実装です:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3044"
></A
><PRE
CLASS="programlisting"
>primplement
lemma_existence {n} () = let
  prfun lemma {n:nat} .&#60;n&#62;.
    (): [t:tree] (isBraun (t), SZ (t, n)) =
    sif n &#62; 0 then let
      stadef nl = n / 2 // size for the left subtree
      stadef nr = n - 1 - nl // size for the right subtree
      val (pfl1, pfl2) = lemma {nl} ()
      and (pfr1, pfr2) = lemma {nr} ()
    in
      (isBraunB (pfl1, pfr1, pfl2, pfr2), SZB (pfl2, pfr2))
    end else
      (isBraunE (), SZE ())
    // end of [sif]
in
  lemma {n} ()
end // end of [lemma_existence]
</PRE
><P
></P
></DIV
>


<FONT
COLOR="RED"
>stadef</FONT
> は、名前と (なんらかの種の) 静的な項の間に静的な束縛を導入するための ATS
のキーワードであることに注意してください。
もし望めば、このキーワードは <FONT
COLOR="RED"
>typedef</FONT
> で置き換えることもできます
(名前と種 <FONT
COLOR="RED"
>t@ype</FONT
> の静的な項を束縛します)。

</P
><P
>次に、同じサイズの2つのブラウンツリーが同一であることを示します。
この性質は次のようにエンコードできます:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3050"
></A
><PRE
CLASS="programlisting"
>extern
prfun
lemma_unicity
  {n:nat}{t1,t2:tree}
(
  pf1: isBraun t1, pf2: isBraun t2, pf3: SZ (t1, n), pf4: SZ (t2, n)
) : EQ (t1, t2) // end of [lemma_unicity]
</PRE
><P
></P
></DIV
>


<FONT
COLOR="RED"
>EQ</FONT
> は次のデータ命題宣言で導入されている命題コンストラクタです:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3053"
></A
><PRE
CLASS="programlisting"
>dataprop EQ (tree, tree) =
  | EQE (E, E) of ()
  | {t1l,t1r:tree}{t2l,t2r:tree}
    EQB (B (t1l, t1r), B (t2l, t2r)) of (EQ (t1l, t2l), EQ (t1r, t2r))
// end of [EQ]
</PRE
><P
></P
></DIV
>


<FONT
COLOR="RED"
>EQ</FONT
> が木の等式を帰納的に定義していることは明確です。
証明関数 <FONT
COLOR="RED"
>lemma_unicity</FONT
> の実装は次のようになります:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3057"
></A
><PRE
CLASS="programlisting"
>primplement
lemma_unicity
  (pf1, pf2, pf3, pf4) = let
  prfun lemma{n:nat}{t1,t2:tree} .&#60;n&#62;.
  (
    pf1: isBraun t1, pf2: isBraun t2, pf3: SZ (t1, n), pf4: SZ (t2, n)
  ) : EQ (t1, t2) =
    sif n &#62; 0 then let
      prval SZB (pf3l, pf3r) = pf3
      prval SZB (pf4l, pf4r) = pf4
      prval isBraunB (pf1l, pf1r, pf1lsz, pf1rsz) = pf1
      prval isBraunB (pf2l, pf2r, pf2lsz, pf2rsz) = pf2
      prval () = SZ_istot (pf1lsz, pf3l) and () = SZ_istot (pf1rsz, pf3r)
      prval () = SZ_istot (pf2lsz, pf4l) and () = SZ_istot (pf2rsz, pf4r)
      prval pfeql = lemma (pf1l, pf2l, pf3l, pf4l)
      prval pfeqr = lemma (pf1r, pf2r, pf3r, pf4r)
    in
      EQB (pfeql, pfeqr)
    end else let
      prval SZE () = pf3 and SZE () = pf4
      prval isBraunE () = pf1 and isBraunE () = pf2
    in
      EQE ()
    end // end of [sif]
in
  lemma (pf1, pf2, pf3, pf4)
end // end of [lemma_unicity]
</PRE
><P
></P
></DIV
>


<FONT
COLOR="RED"
>lemma_unicity</FONT
> のこの実装内の証明関数 <FONT
COLOR="RED"
>SZ_istot</FONT
>
は次のインターフェイスを持つことに注意してください:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3061"
></A
><PRE
CLASS="programlisting"
>extern
prfun SZ_istot{t:tree}{n1,n2:int}
  (pf1: SZ (t, n1), pf2: SZ (t, n2)): [n1==n2] void
</PRE
><P
></P
></DIV
>


これは <FONT
COLOR="RED"
>SZ</FONT
> がその最初のパラメータに関して関数的な関係であることを単純に表わしています。
つまり、<FONT
COLOR="RED"
>SZ</FONT
> によって関係付けられた t と n があるとい、どのような t が与えられても1つ以上の n
が存在します。

明確に、この実装に対応する数学的証明は与えられた2つの木 t1 と t2 のサイズ n に対する帰納法で証明されます。
n が 0 の基底部では、t1 と t2 は両方とも空の木なので等しくなります。
n &#62; 0 の場合、帰納的に、それぞれ t1 と t2 の左の子のサイズである n1l と n2l が同じ値であることを証明します;
同様に、それぞれ t1 と t2 の右の子のサイズである n1r と n2r が同じ値であることを証明します;
n1l について帰納法の仮定から、t1 と t2 の左の子は同じです;
n1r について帰納法の仮定から、t1 と t2 の右の子は同じです;
木の等式の定義 (<FONT
COLOR="RED"
>EQ</FONT
> にエンコードされています) から、t1 と t2 は同じです。
</P
><P
>&#13;比較として、次のコードは <FONT
COLOR="RED"
>lemma_unicity</FONT
> の別の実装ですが、少し独特のスタイルです:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3068"
></A
><PRE
CLASS="programlisting"
>primplement
lemma_unicity
  (pf1, pf2, pf3, pf4) = let
  prfun lemma{n:nat}{t1,t2:tree} .&#60;t1&#62;.
  (
    pf1: isBraun t1, pf2: isBraun t2, pf3: SZ (t1, n), pf4: SZ (t2, n)
  ) : EQ (t1, t2) =
    case+ (pf1, pf2) of
    | (isBraunE (), isBraunE ()) =&#62; EQE ()
    | (isBraunB (pf11, pf12, pf13, pf14),
       isBraunB (pf21, pf22, pf23, pf24)) =&#62; let
//
        prval SZB (pf31, pf32) = pf3
        prval SZB (pf41, pf42) = pf4
//
        prval () = SZ_istot (pf13, pf31)
        prval () = SZ_istot (pf23, pf41)
//
        prval () = SZ_istot (pf14, pf32)
        prval () = SZ_istot (pf24, pf42)
//
        prval pfeq1 = lemma (pf11, pf21, pf31, pf41)
        prval pfeq2 = lemma (pf12, pf22, pf32, pf42)
      in
        EQB (pfeq1, pfeq2)
      end
    | (isBraunE _, isBraunB _) =/=&#62; let
        prval SZE _ = pf3 and SZB _ = pf4 in (*none*)
      end
    | (isBraunB _, isBraunE _) =/=&#62; let
        prval SZB _ = pf3 and SZE _ = pf4 in (*none*)
      end
in
  lemma (pf1, pf2, pf3, pf4)
end // end of [lemma_unicity]
</PRE
><P
></P
></DIV
>


この実装は与えられた木 t1 の構造に対する帰納法の証明に対応します。
特殊記号 <FONT
COLOR="RED"
>=/=&#62;</FONT
> の使用に注意してください。
これは ATS のキーワードで、パターンマッチに含まれる節が <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>到達不能</I
></SPAN
> であることを ATS
の型検査器に指示します;
節の右辺に嘘を書くのはプログラマの責務です。
上記のコード全体は <A
HREF="http://ats-lang.sourceforge.net/DOCUMENT/INT2PROGINATS/CODE/CHAP_THMPRVING/brauntree.dats"
TARGET="_top"
>オンライン</A
> から入手できます。
</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x2990.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x3073.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>代数的なデータ種 (datasort)</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c2842.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>プログラマ中心の定理証明</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>