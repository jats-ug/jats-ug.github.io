<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>例: 検証された高速な累乗</TITLE
><META
CHARSET="UTF-8"><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="ATSプログラミング入門"
HREF="book1.html"><LINK
REL="UP"
TITLE="定理証明によるプログラミング"
HREF="c3140.html"><LINK
REL="PREVIOUS"
TITLE="例: もう一つの検証された階乗"
HREF="x3227.html"><LINK
REL="NEXT"
TITLE="線形観と線形型を使ったプログラミング"
HREF="p3305.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="./assets/INT2PROGINATS-BOOK.css"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>ATSプログラミング入門: </TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x3227.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 12. 定理証明によるプログラミング</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="p3305.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="example_verified_fast_exponentiation"
>例: 検証された高速な累乗</A
></H1
><P
>整数 x が与えられた時、pow(x, n)、つまり x の n 乗、は次のように帰納的に宣言することができます:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3254"
></A
><PRE
CLASS="programlisting"
>pow (x, 0) = 1
pow (x, n) = x * pow (x, n-1) (for all n &#62; 0)
</PRE
><P
></P
></DIV
>


この定義の直接的な実装は次のようになります:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3256"
></A
><PRE
CLASS="programlisting"
>fun ipow {n:nat} .&#60;n&#62;.
  (x: int, n: int n): int = if n &#62; 0 then x * ipow (x, n-1) else 1
// end of [ipow]
</PRE
><P
></P
></DIV
>


この実装の時間的計算量は (乗法を O(1) と仮定すると) O(n) になります。
より効率的な実装は次のようになるでしょう:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3258"
></A
><PRE
CLASS="programlisting"
>fun ifastpow {n:nat} .&#60;n&#62;.
  (x: int, n: int n): int =
  if n &#62; 0 then let
    val n2 = n/2; i = n-(2*n2)
  in
    if i &#62; 0 then ifastpow (x*x, n2) else x * ifastpow (x*x, n2)
  end else 1
// end of [ifastpow]
</PRE
><P
></P
></DIV
>


ここでは、もし n が偶数であれば pow(x, n) は pow(x*x, n/2) に等しく、もし n が奇数であれば pow(x, n) は x * pow(x*x, n/2) に等しい、という性質を使っています。
これは高速な累乗と呼ばれています。
<FONT
COLOR="RED"
>ifastpow</FONT
> の時間的計算量は O(log(n)) であることに注意してください。

</P
><P
>&#13;明確に、上記は整数の累乗に限定されたものではありません。
用いている乗法が結合的である限り、どのような要素の累乗を計算するのにも高速な累乗を使うことができます。
特に、正方行列の累乗はこの方法で計算できます。
高速な累乗の検証された一般化実装を次に紹介します。

</P
><P
>検証された実装の中で一般化されたデータを正確に扱うために、しばしば ATS
の型システムにおいて技巧的なテクニックが必要です。
はじめに、次のような抽象型コンストラクタ <FONT
COLOR="RED"
>E</FONT
> を導入してみましょう:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3264"
></A
><PRE
CLASS="programlisting"
>sortdef elt = int // [elt] is just an alias for [int]
abst@ype E (a:t@ype, x:elt) = a // [x] is an imaginary stamp
</PRE
><P
></P
></DIV
>


これはしばしば <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>スタンプ化 (stamping)</I
></SPAN
> と呼ばれます。
それぞれの型 T とスタンプ X について、関連するデータ表現に関する限り <FONT
COLOR="RED"
>E(T, x)</FONT
> は単に T です。
このスタンプは架空の存在で、仕様の目的にだけ使われます。
次に抽象命題型 <FONT
COLOR="RED"
>MUL</FONT
> と関数テンプレート <FONT
COLOR="RED"
>mul_elt_elt</FONT
> を導入します:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3270"
></A
><PRE
CLASS="programlisting"
>absprop MUL (elt, elt, elt) // abstract mul relation

fun{a:t@ype}
mul_elt_elt {x,y:elt}
  (x: E (a, x), y: E (a, y)): [xy:elt] (MUL (x, y, xy) | E (a, xy))
// end of [mul_elt_elt]
</PRE
><P
></P
></DIV
>


<FONT
COLOR="RED"
>MUL</FONT
> と
<A
HREF="http://ats-lang.sourceforge.net/DOCUMENT/ATS-Postiats/prelude/SATS/arith_prf.sats"
TARGET="_top"
>arith_prf.sats</A
> で宣言されている同じ名前の型に混乱しないでください。
エンコードされた乗法が結合的であることを示すために、次の証明関数を導入することができます:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3274"
></A
><PRE
CLASS="programlisting"
>praxi mul_assoc
  {x,y,z:elt}{xy,yz:elt}{xy_z,x_yz:elt}
(
  pf1: MUL (x, y, xy), pf2: MUL (xy, z, xy_z)
, pf3: MUL (y, z, yz), pf4: MUL (x, yz, x_yz)
) : [xy_z==x_yz] void
</PRE
><P
></P
></DIV
>


キーワード <FONT
COLOR="RED"
>praxi</FONT
> は <FONT
COLOR="RED"
>mul_assoc</FONT
>
を実装されることを期待しない公理として扱うことを示します。

</P
><P
>&#13;抽象的な累乗関数は、抽象命題型 <FONT
COLOR="RED"
>MUL</FONT
> の項ですぐに指定できます:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3280"
></A
><PRE
CLASS="programlisting"
>dataprop POW (
  elt(*base*), int(*exp*), elt(*res*)
) = // res = base^exp
  | {x:elt} POWbas (x, 0, 1(*unit*))
  | {x:elt}{n:nat}{p,p1:elt}
    POWind (x, n+1, p1) of (POW (x, n, p), MUL (x, p, p1))
// end of [POW]
</PRE
><P
></P
></DIV
>


予想される通り、一般化された高速な累乗は次のインターフェイスで与えられます:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3282"
></A
><PRE
CLASS="programlisting"
>fun{a:t@ype}
fastpow_elt_int{x:elt}{n:nat}
  (x: E (a, x), n: int n): [p:elt] (POW (x, n, p) | E (a, p))
// end of [fastpow_elt_int]
</PRE
><P
></P
></DIV
>


</P
><P
>&#13;上までで準備が整ったので、<FONT
COLOR="RED"
>fastpow_elt_int</FONT
> の率直な実装は次のようになります:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3286"
></A
><PRE
CLASS="programlisting"
>implement{a}
fastpow_elt_int (x, n) = let
//
// lemma: (x*x)^n = x^(2n)
//
extern
prfun
lemma{x:elt}{xx:elt}{n:nat}{y:elt}
  (pfxx: MUL (x, x, xx), pfpow: POW (xx, n, y)): POW (x, 2*n, y)
//
in
  if n &#62; 0 then let
    val n2 = n / 2; val i = n - (n2+n2) // i = 0 or 1
    val (pfxx | xx) = mul_elt_elt (x, x) // xx = x*x
    val (pfpow2 | res) = fastpow_elt_int&#60;a&#62; (xx, n2) // xx^n2 = res
    prval pfpow = lemma (pfxx, pfpow2) // pfpow: x^(2*n2) = res
  in
    if i &#62; 0 then let
      val (pfmul | xres) = mul_elt_elt&#60;a&#62; (x, res) // xres = x*res
    in
      (POWind (pfpow, pfmul) | xres)
    end else (pfpow | res)
  end else let
    val res = mulunit&#60;a&#62; () in (POWbas () | res) // res = 1
  end (* end of [if] *)
end // end of [fastpow_elt_int]
</PRE
><P
></P
></DIV
>


<FONT
COLOR="RED"
>fastpow_elt_int</FONT
> のこの実装は末尾再帰でないことに注意してください。
用いる乗法の単位元を作るために呼び出す関数テンプレート <FONT
COLOR="RED"
>mulunit</FONT
>
には次のインターフェイスが割り当てられます:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3290"
></A
><PRE
CLASS="programlisting"
>fun{a:t@ype} mulunit (): E (a, 1(*stamp*))
</PRE
><P
></P
></DIV
>


証明関数 <FONT
COLOR="RED"
>lemma</FONT
> は、それぞれの自然数 n について pow(x, 2*n)=pow(x*x, n) を立証しています。
私が実装した <FONT
COLOR="RED"
>lemma</FONT
> はオンラインから入手できます。
けれども興味のある読者には、私の実装を見る前に実装してみることを提案します。
<FONT
COLOR="RED"
>lemma</FONT
> の実装には次の公理が必要になることに注意してください:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN3295"
></A
><PRE
CLASS="programlisting"
>praxi
mul_istot // [MUL] is total
  {x,y:elt} ((*void*)): [xy:elt] MUL (x, y, xy)
praxi
mul_isfun{x,y:elt}{z1,z2:elt} // MUL is functional
  (pf1: MUL (x, y, z1), pf2: MUL (x, y, z2)): [z1==z2] void
</PRE
><P
></P
></DIV
>


別の興味深い (そしてておそらく少しやりがいのある) 課題は
<FONT
COLOR="RED"
>fastpow_elt_int</FONT
> を末尾再帰的に実装することでしょう。

</P
><P
>&#13;オンラインから入手できる2つのファイル
<A
HREF="http://ats-lang.sourceforge.net/DOCUMENT/INT2PROGINATS/CODE/CHAP_PRGTHMPRV/fastexp.sats"
TARGET="_top"
>fastexp.sats</A
> と
<A
HREF="http://ats-lang.sourceforge.net/DOCUMENT/INT2PROGINATS/CODE/CHAP_PRGTHMPRV/fastexp.dats"
TARGET="_top"
>fastexp.dats</A
>
は上記に示したコード全体を含んでいます。

</P
><P
>&#13;これで <FONT
COLOR="RED"
>fastpow_elt_int</FONT
> を実装するできました。
これをどうやって使うのでしょうか？
2 x 2 行列の高速な累乗を実装した <FONT
COLOR="RED"
>fastpow_elt_int</FONT
> の例が
<A
HREF="http://ats-lang.sourceforge.net/DOCUMENT/INT2PROGINATS/CODE/CHAP_PRGTHMPRV/test_fastexp.dats"
TARGET="_top"
>オンライン</A
> から入手できます。
これでフィボナッチ数を効率的に計算できるようになります。

</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x3227.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="p3305.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>例: もう一つの検証された階乗</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c3140.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>線形観と線形型を使ったプログラミング</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>