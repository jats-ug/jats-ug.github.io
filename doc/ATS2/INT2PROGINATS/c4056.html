<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Abstract Views and Viewtypes</TITLE
><META
CHARSET="UTF-8"><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="ATSプログラミング入門"
HREF="index.html"><LINK
REL="UP"
TITLE="Programming with Linear Views and Types"
HREF="p3216.html"><LINK
REL="PREVIOUS"
TITLE="Transition from Datatypes to Dataviewtypes"
HREF="x4024.html"><LINK
REL="NEXT"
TITLE="Memory Allocation and Deallocation"
HREF="x4078.html"></HEAD
><BODY
CLASS="chapter"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>ATSプログラミング入門: </TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x4024.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x4078.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="chapter"
><H1
><A
NAME="abstract_views_viewtypes"
></A
>Chapter 16. Abstract Views and Viewtypes</H1
><P
>&#13;I have so far given a presentation of views that solely focuses on at-views
and the views built on top of at-views. This is largely due to at-views
being the form of most widely used views in practice and also being the
first form of views supported in ATS. However, other forms of views can be
readily introduced into ATS abstractly. Even in a case where a view can be
defined based on at-views (or other forms of views), one may still want to
introduce it as an abstract view (accompanied with certain proof functions
for performing view-changes). Often what the programmer really needs is to
figure out <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>conceptually</I
></SPAN
> whether abstractly defined views and
proof functions for manipulating them actually make sense. This is a bit
like arguing whether a function is computable: There is rarely a need, if
at all, to actually encode the function as a Turing-machine to prove its
being computable. IMHO, learning proper use of abstract views and abstract
viewtypes is a necessary step for one to take in order to employ linear
types effectively in practice to deal with resource-related programming
issues.

</P
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="simple-linear-objects"
>16.1. Simple Linear Objects</A
></H1
><P
>&#13;Objects in the physical world are conspicuously linear: They cannot be
created from nothing or simply go vanished by turning into nothing. Thus,
it is only natural to assign linear types to values that represent physical
objects. I choose the name <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>simple linear object</I
></SPAN
> here to refer
to a linear value representing an object of some sort that does not contain
built-in mechanism for supporting inheritance.
</P
><P
>&#13;Let us now take a look at a concrete example of simple linear object.
The following code presents an interface for a timer (that is, stopwatch):

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4065"
></A
><PRE
CLASS="programlisting"
>absvtype timer_vtype
vtypedef timer = timer_vtype

fun timer_new (): timer
fun timer_free (x: timer): void
fun timer_start (x: !timer): void
fun timer_finish (x: !timer): void
fun timer_pause (x: !timer): void
fun timer_resume (x: !timer): void
fun timer_get_ntick (x: !timer): uint
fun timer_reset (x: !timer): void
</PRE
><P
></P
></DIV
>


The state of a timer is given the
record type <FONT
COLOR="RED"
>timer_struct</FONT
> defined as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4068"
></A
><PRE
CLASS="programlisting"
>typedef
timer_struct = @{
  started= bool // the timer has started
, running= bool // the timer is running
  // the tick number recorded when the timer
, ntick_beg= uint // was turned on last time
, ntick_acc= uint // the number of accumulated ticks
} (* end of [timer_struct] *)
</PRE
><P
></P
></DIV
>


The following linear datatype <FONT
COLOR="RED"
>timer</FONT
>
is declared for timers, and the abstract type <FONT
COLOR="RED"
>timer_vtype</FONT
>
is assumed to equal <FONT
COLOR="RED"
>timer</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4073"
></A
><PRE
CLASS="programlisting"
>//
datavtype timer =
  TIMER of (timer_struct)
//
assume timer_vtype = timer
//
</PRE
><P
></P
></DIV
>


</P
><P
>&#13;Various functions on timers can now be readily implemented.
Let us first see the code for creating and freeing timers:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4076"
></A
><PRE
CLASS="programlisting"
>&#13;implement
timer_new () = let
//
val timer = TIMER (_)
val+TIMER (x) = timer
//
val () = x.started := false
val () = x.running := false
val () = x.ntick_beg := 0u
val () = x.ntick_acc := 0u
//
prval () = fold@ (timer)
//
in
  timer
end // end of [timer_new]

implement
timer_free (timer) =
  let val+~TIMER _ = timer in (*nothing*) end
// end of [timer_free]

</PRE
><P
></P
></DIV
>


</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x4024.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x4078.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Transition from Datatypes to Dataviewtypes</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="p3216.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Memory Allocation and Deallocation</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>