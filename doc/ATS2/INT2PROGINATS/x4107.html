<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>datatype から dataviewtype への翻訳</TITLE
><META
CHARSET="UTF-8"><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="ATSプログラミング入門"
HREF="book1.html"><LINK
REL="UP"
TITLE="線形 datatype としての dataviewtype"
HREF="c3764.html"><LINK
REL="PREVIOUS"
TITLE="線形2分探索木"
HREF="x4053.html"><LINK
REL="NEXT"
TITLE="抽象 view と viewtype"
HREF="c4139.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="./assets/INT2PROGINATS-BOOK.css"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>ATSプログラミング入門: </TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x4053.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 15. 線形 datatype としての dataviewtype</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c4139.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="transition_from_datatypes_to_dataviewtypes"
>datatype から dataviewtype への翻訳</A
></H1
><P
>&#13;多くのプログラマは、dataviewtype の値を操作するコードを書くことを幾分複雑に感じると思います。
込み入ったデータ構造を扱う時、しばしば私は datatype をはじめに使おうとすることがあります。
そのデータ構造をモデリングして、datatype を用いてそのデータ構造のいくつかの機能を実装してみるのです。
それからその datatype を対応する dataviewtype に変換し、dataviewtype として動作するようにその実装を修正します。
ここでは、以前の <A
HREF="x2799.html"
>implementation of functional red-black trees</A
> を元にした線形赤黒木の実装を次に示します。
これは datatype から dataviewtype への漸進的な翻訳を具体的に説明しています。
dataviewtype を直接用いてプログラミングしようとする際の難易度を大きく減少させることができるのです。

</P
><P
>&#13;次の dataviewtype <FONT
COLOR="RED"
>rbtree</FONT
> 宣言は以前の datatype <FONT
COLOR="RED"
>rbtree</FONT
> 宣言とほぼ一致しています。
違うのはキーワード <FONT
COLOR="RED"
>datatype</FONT
> の代わりに、キーワード <FONT
COLOR="RED"
>datavtype</FONT
> を使っている点です:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4116"
></A
><PRE
CLASS="programlisting"
>#define BLK 0; #define RED 1
sortdef clr = {c:int | 0 &#60;= c; c &#60;= 1}

datavtype rbtree
(
  a: t@ype+, int(*c*), int(*bh*), int(*v*)
) = // element type, color, black height, violations
  | rbtree_nil (a, BLK, 0, 0) of ((*void*))
  | {c,cl,cr:clr}{bh:nat}{v:int}
    {c==BLK &#38;&#38; v==0 || c == RED &#38;&#38; v==cl+cr}
    rbtree_cons (a, c, bh+1-c, v) of (int c, rbtree0 (a, cl, bh), a, rbtree0 (a, cr, bh))
// end of [rbtree]

where rbtree0 (a:t@ype, c:int, bh:int) = rbtree (a, c, bh, 0)
</PRE
><P
></P
></DIV
>


</P
><P
>&#13;ひと目見たところ、次の関数テンプレート <FONT
COLOR="RED"
>insfix_l</FONT
> は (関数的な赤黒木の)
同じ名前の関数よりもはるかに複雑です:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4120"
></A
><PRE
CLASS="programlisting"
>fn{
a:t@ype
} insfix_l // right rotation
  {cl,cr:clr}
  {bh:nat}{v:nat}
  {l,l_c,l_tl,l_x,l_tr:addr}
(
  pf_c: int(BLK) @ l_c
, pf_tl: rbtree (a, cl, bh, v) @ l_tl
, pf_x: a @ l_x
, pf_tr: rbtree (a, cr, bh, 0) @ l_tr
| t: rbtree_cons_unfold (l, l_c, l_tl, l_x, l_tr)
, p_tl: ptr (l_tl)
) : [c:clr] rbtree0 (a, c, bh+1) = let
  #define B BLK
  #define R RED
  #define nil rbtree_nil
  #define cons rbtree_cons
in
  case+ !p_tl of
  | @cons (cl as R, tll as @cons (cll as R, _, _, _), _, tlr) =&#62; let
//
      val () = cll := B
      prval () = fold@ (tll)
//
      val tl = !p_tl
      val () = !p_tl := tlr
      prval () = fold@ (t)
      val () = tlr := t
//
    in
      fold@ (tl); tl
    end // end of [cons (R, cons (R, ...), ...)]
  | @cons (cl as R, tll, _, tlr as @cons (clr as R, tlrl, _, tlrr)) =&#62; let
//
      val tl = !p_tl
      val () = !p_tl := tlrr
      prval () = fold@ (t)
      val () = tlrr := t
//
      val tlr_ = tlr
      val () = tlr := tlrl
      val () = cl := B
      prval () = fold@ (tl)
      val () = tlrl := tl
//
    in
      fold@ (tlr_); tlr_
    end // end of [cons (R, ..., cons (R, ...))]
  | _ (*rest-of-cases*) =&#62;&#62; (fold@ (t); t)
end // end of [insfix_l]
</PRE
><P
></P
></DIV
>


けれども、上記の <FONT
COLOR="RED"
>insfix_l</FONT
> のインターフェイスは以前示した <FONT
COLOR="RED"
>infix_l</FONT
> のインターフェイスを
<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>直接</I
></SPAN
> 翻訳したものだと指摘したいのです。
別の言い方をすると、以前の実装は回転される木と <FONT
COLOR="RED"
>infix_l</FONT
>
をそれに適用して得られる木との関係を捕捉していました。
これはまた線形赤黒木でも維持されています。
次の関数テンプレート <FONT
COLOR="RED"
>insfix_r</FONT
> のようによく似た文を作ることができます。
これは <FONT
COLOR="RED"
>insfix_l</FONT
> の正確な鏡像になっています:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4128"
></A
><PRE
CLASS="programlisting"
>fn{
a:t@ype
} insfix_r // left rotation
  {cl,cr:clr}
  {bh:nat}{v:nat}
  {l,l_c,l_tl,l_x,l_tr:addr} (
  pf_c: int(BLK) @ l_c
, pf_tl: rbtree (a, cl, bh, 0) @ l_tl
, pf_x: a @ l_x
, pf_tr: rbtree (a, cr, bh, v) @ l_tr
| t: rbtree_cons_unfold (l, l_c, l_tl, l_x, l_tr)
, p_tr: ptr (l_tr)
) : [c:clr] rbtree0 (a, c, bh+1) = let
  #define B BLK
  #define R RED
  #define nil rbtree_nil
  #define cons rbtree_cons
in
  case+ !p_tr of
  | @cons (cr as R, trl, _, trr as @cons (crr as R, _, _, _)) =&#62; let
//
      val () = crr := B
      prval () = fold@ (trr)
//
      val tr = !p_tr
      val () = !p_tr := trl
      prval () = fold@ (t)
      val () = trl := t
//
    in
      fold@ (tr); tr
    end // end of [cons (R, ..., cons (R, ...))]
  | @cons (cr as R, trl as @cons (crr as R, trll, _, trlr), _, trr) =&#62; let
//
      val tr = !p_tr
      val () = !p_tr := trll
      prval () = fold@ (t)
      val () = trll := t
//
      val trl_ = trl
      val () = trl := trlr
      val () = cr := B
      prval () = fold@ (tr)
      val () = trlr := tr
//
    in
      fold@ (trl_); trl_
    end // end of [cons (R, cons (R, ...), ...)]
  | _ (*rest-of-cases*) =&#62;&#62; (fold@ (t); t)
end // end of [insfix_r]
</PRE
><P
></P
></DIV
>


</P
><P
>&#13;予想されることですが、本質的に次の関数テンプレート <FONT
COLOR="RED"
>rbtree_insert</FONT
>
は、関数的な赤黒木に要素を挿入する同じ名前の実装の直接的な翻訳です:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4132"
></A
><PRE
CLASS="programlisting"
>extern
fun{a:t@ype}
rbtree_insert
  {c:clr}{bh:nat}
(
  t: rbtree0 (a, c, bh), x0: &#38;a, cmp: cmp a
) : [bh1:nat] rbtree0 (a, BLK, bh1)

implement{a}
rbtree_insert
  (t, x0, cmp) = let
//
#define B BLK
#define R RED
#define nil rbtree_nil
#define cons rbtree_cons
//
fun ins
  {c:clr}{bh:nat} .&#60;bh,c&#62;.
(
  t: rbtree0 (a, c, bh), x0: &#38;a
) : [cl:clr; v:nat | v &#60;= c] rbtree (a, cl, bh, v) =
(
  case+ t of
  | @cons (
      c, tl, x, tr
    ) =&#62; let
      prval pf_c = view@c
      prval pf_tl = view@tl
      prval pf_x = view@x
      prval pf_tr = view@tr
      val sgn = compare&#60;a&#62; (x0, x, cmp)
    in
      if sgn &#60; 0 then let
        val [cl:int,v:int] tl_ = ins (tl, x0)
        val () = tl := tl_
      in
        if (c = B)
        then (
          insfix_l&#60;a&#62;
            (pf_c, pf_tl, pf_x, pf_tr | t, addr@tl)
          // end of [insfix_l]
        ) else let
          val () = c := R in fold@{a}{..}{..}{cl}(t); t
        end // end of [if]
      end else if sgn &#62; 0 then let
        val [cr:int,v:int] tr_ = ins (tr, x0)
        val () = tr := tr_
      in
        if (c = B)
        then (
          insfix_r&#60;a&#62;
            (pf_c, pf_tl, pf_x, pf_tr | t, addr@tr)
          // end of [insfix_r]
        ) else let
          val () = c := R in fold@{a}{..}{..}{cr}(t); t
        end // end of [if]
      end else (fold@{a}{..}{..}{0} (t); t)
    end // end of [cons]
  | ~nil () =&#62; cons{a}{..}{..}{0}(R, nil, x0, nil)
) (* end of [ins] *)
//
val t = ins (t, x0)
//
in
//
case+ t of @cons(c as R, _, _, _) =&#62; (c := B; fold@ (t); t) | _ =&#62;&#62; t
//
end // end of [rbtree_insert]
</PRE
><P
></P
></DIV
>


</P
><P
>&#13;私は文字通り以前の関数的な赤黒木の <FONT
COLOR="RED"
>rbtree_insert</FONT
>
実装をコピーし、それから型検査を通るように適切に修正して、上記の <FONT
COLOR="RED"
>rbtree_insert</FONT
> を実装しました。
このコピーして修正する作業は外見的には難しく見えますが、型検査して起きるエラーメッセージに従えばそのほとんどはかなり単純です。

</P
><P
>&#13;この章のコード全体と追加のテストコードは
<A
HREF="http://ats-lang.sourceforge.net/DOCUMENT/INT2PROGINATS/CODE/CHAP_DATAVTYPE/rbtree.dats"
TARGET="_top"
>オンライン</A
>
から入手できます。
与えられた線形赤黒木から要素を削除する操作を実装することは、読者にとってやりがいのある練習問題でしょう。

</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x4053.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c4139.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>線形2分探索木</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c3764.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>抽象 view と viewtype</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>