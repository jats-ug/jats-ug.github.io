<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Example: Function Templates on Lists</TITLE
><META
CHARSET="UTF-8"><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="ATSプログラミング入門"
HREF="index.html"><LINK
REL="UP"
TITLE="Parametric Polymorphism"
HREF="c1121.html"><LINK
REL="PREVIOUS"
TITLE="Polymorphic Datatypes"
HREF="x1210.html"><LINK
REL="NEXT"
TITLE="Example: Mergesort on Lists"
HREF="x1328.html"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>ATSプログラミング入門: </TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x1210.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 5. Parametric Polymorphism</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x1328.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="example_function_templates_on_lists"
>5.4. Example: Function Templates on Lists</A
></H1
><P
>&#13;In functional programming, lists are ubiquitous. We implement as follows
some commonly used function templates on lists. It should be noted that
these templates are all available in some library of ATS, where they may be
implemented in a significantly more efficient manner due to the use of
certain programming features (such as linear datatypes) that have not been
covered so far.
</P
><P
>&#13;Please find the entire code in this section plus some additional
code for testing <A
HREF="http://www.ats-lang.org/DOCUMENT/INT2PROGINATS/CODE/CHAP_POLYMORPH/listfun.dats"
TARGET="_top"
>on-line</A
>.
</P
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="list0_append"
>5.4.1. Appending: <FONT
COLOR="RED"
>list0_append</FONT
></A
></H2
><P
>&#13;Given two lists xs and ys of the type <FONT
COLOR="RED"
>list0(T)</FONT
> for some type T,
<FONT
COLOR="RED"
>list0_append(xs, ys)</FONT
> returns a list that is the concatenation
of xs and ys:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1256"
></A
><PRE
CLASS="programlisting"
>fun{
a:t@ype
} list0_append
(
  xs: list0 a
, ys: list0 a
) : list0 a =
(
case+ xs of
| list0_cons (x, xs) =&#62;
    list0_cons{a}(x, list0_append&#60;a&#62; (xs, ys))
| list0_nil ((*void*)) =&#62; ys
) (* end of [list0_append] *)
</PRE
><P
></P
></DIV
>


Clearly, this implementation of <FONT
COLOR="RED"
>list0_append</FONT
> is not
tail-recursive.
</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="list0_reverse_append"
>5.4.2. Reverse-Appending: <FONT
COLOR="RED"
>list0_reverse_append</FONT
></A
></H2
><P
>&#13;Given two lists xs and ys of the type <FONT
COLOR="RED"
>list0(T)</FONT
> for some type T,
<FONT
COLOR="RED"
>list0_reverse_append(xs, ys)</FONT
> returns a list that is the
concatenation of the reverse of xs and ys:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1265"
></A
><PRE
CLASS="programlisting"
>fun{
a:t@ype
} list0_reverse_append
(
  xs: list0 a, ys: list0 a
) : list0 a =
(
case+ xs of
| list0_cons (x, xs) =&#62;
    list0_reverse_append&#60;a&#62; (xs, list0_cons{a}(x, ys))
| list0_nil () =&#62; ys
) (* end of [list0_reverse_append] *)
</PRE
><P
></P
></DIV
>


Clearly, this implementation of <FONT
COLOR="RED"
>list0_reverse_append</FONT
> is
tail-recursive.
</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="list0_reverse"
>5.4.3. Reversing: <FONT
COLOR="RED"
>list0_reverse</FONT
></A
></H2
><P
>&#13;Given a list xs, <FONT
COLOR="RED"
>list0_reverse(xs)</FONT
> returns the
reverse of xs:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1273"
></A
><PRE
CLASS="programlisting"
>fun{a:t@ype}
list0_reverse
  (xs: list0 a): list0 a = list0_reverse_append&#60;a&#62; (xs, list0_nil)
// end of [list0_reverse]
</PRE
><P
></P
></DIV
>

</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="list0_map"
>5.4.4. Mapping: <FONT
COLOR="RED"
>list0_map</FONT
></A
></H2
><P
>&#13;Given a list xs of the type <FONT
COLOR="RED"
>list0(T1)</FONT
> for some type T1 and a
closure function f of the type T1 -&#60;cloref1&#62; T2 for some type T2,
<FONT
COLOR="RED"
>list0_map(xs)</FONT
> returns a list ys of the type <FONT
COLOR="RED"
>list0(T2)</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1282"
></A
><PRE
CLASS="programlisting"
>fun
{a:t@ype}
{b:t@ype}
list0_map
(
  xs: list0 a, f: a -&#60;cloref1&#62; b
) : list0 b =
(
case+ xs of
| list0_cons (x, xs) =&#62;
    list0_cons{b}(f x, list0_map&#60;a&#62;&#60;b&#62; (xs, f))
| list0_nil ((*void*)) =&#62; list0_nil ()
) (* end of [list0_map] *)
</PRE
><P
></P
></DIV
>


The length of ys equals that of xs and each element y in ys equals f(x),
where x is the corresponding element in xs.  Clearly, this implementation
of <FONT
COLOR="RED"
>list0_map</FONT
> is not tail-recursive.
</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="list0_foldleft"
>5.4.5. Left-Folding: <FONT
COLOR="RED"
>list0_foldleft</FONT
></A
></H2
><P
>&#13;Given xs, ini and f, <FONT
COLOR="RED"
>list0_foldleft(ini, xs, f)</FONT
> computes the
value of the expression f(... f(f(ini, xs[0]), xs[1]) ..., xs[n-1]), where
n is the length of xs and xs[i] refers to element i in xs for each i &#60; n.
The following implementation of <FONT
COLOR="RED"
>list0_foldleft</FONT
> is tail-recursive:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1291"
></A
><PRE
CLASS="programlisting"
>fun
{a:t@ype}
{b:t@ype}
list0_foldleft
(
  ini: a, xs: list0 (b), f: (a, b) -&#62; a
) : a =
(
  case+ xs of
  | list0_cons
      (x, xs) =&#62; list0_foldleft&#60;a&#62;&#60;b&#62; (f (ini, x), xs, f)
  | list0_nil ((*void*)) =&#62; ini
)
</PRE
><P
></P
></DIV
>


</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="list0_foldright"
>5.4.6. Right-Folding: <FONT
COLOR="RED"
>list0_foldright</FONT
></A
></H2
><P
>&#13;Given xs, res and f, <FONT
COLOR="RED"
>list0_foldright(xs, res, f)</FONT
> computes the
value of the expression f(xs[0], f(xs[1], f(... f(xs[n-1], res) ...))), where
n is the length of xs and xs[i] refers to element i in xs for each i &#60; n.
The following implementation of <FONT
COLOR="RED"
>list0_foldright</FONT
> is not tail-recursive:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1299"
></A
><PRE
CLASS="programlisting"
>fun
{a:t@ype}
{b:t@ype}
list0_foldright
(
  xs: list0 (a), res: b, f: (a, b) -&#62; b
) : b =
(
  case+ xs of
  | list0_cons
      (x, xs) =&#62; f (x, list0_foldright&#60;a&#62;&#60;b&#62; (xs, res, f))
  | list0_nil ((*void*)) =&#62; res
)
</PRE
><P
></P
></DIV
>


</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="list0_zip"
>5.4.7. Zipping: <FONT
COLOR="RED"
>list0_zip</FONT
></A
></H2
><P
>&#13;Given two lists xs and ys of the types <FONT
COLOR="RED"
>list0(T1)</FONT
> and
<FONT
COLOR="RED"
>list0(T2)</FONT
> for some types T1 and T2, respectively,
<FONT
COLOR="RED"
>list0_zip(xs, ys)</FONT
> returns a list zs of the type <FONT
COLOR="RED"
>list0
@(T1, T2)</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1309"
></A
><PRE
CLASS="programlisting"
>fun{
a,b:t@ype
} list0_zip
(
  xs: list0 a
, ys: list0 b
) : list0 @(a, b) = let
  typedef ab = @(a, b)
in
//
case+ (xs, ys) of
| (list0_cons (x, xs),
   list0_cons (y, ys)) =&#62;
  (
    list0_cons{ab}((x, y), list0_zip&#60;a,b&#62; (xs, ys))
  )
| (_, _) =&#62; list0_nil ()
//
end // end of [list0_zip]
</PRE
><P
></P
></DIV
>


The length of zs is the minimum of the lengths of xs and ys and each
element z in zs equals @(x, y), where x and y are the corresponding
elements in xs and ys, respectively.  Clearly, this implementation of
<FONT
COLOR="RED"
>list0_zip</FONT
> is not tail-recursive.
</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="list0_zipwith"
>5.4.8. Zipping with: <FONT
COLOR="RED"
>list0_zipwith</FONT
></A
></H2
><P
>&#13;Given two lists xs and ys of the types <FONT
COLOR="RED"
>list0(T1)</FONT
> and
<FONT
COLOR="RED"
>list0(T2)</FONT
> for some types T1 and T2, respectively, and a closure
function f of the type (T1, T2) -&#60;cloref1&#62; T3 for some type T3,
<FONT
COLOR="RED"
>list0_zipwith(xs, ys, f)</FONT
> returns a list zs of the type
<FONT
COLOR="RED"
>list0(T3)</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1320"
></A
><PRE
CLASS="programlisting"
>fun
{a,b:t@ype}
{c:t@ype}
list0_zipwith
(
  xs: list0 a
, ys: list0 b
, f: (a, b) -&#60;cloref1&#62; c
) : list0 c =
(
case+ (xs, ys) of
| (list0_cons (x, xs),
   list0_cons (y, ys)) =&#62;
  (
    list0_cons{c}(f (x, y), list0_zipwith&#60;a,b&#62;&#60;c&#62; (xs, ys, f))
  )
| (_, _) =&#62; list0_nil ()
) (* end of [list0_zipwith] *)
</PRE
><P
></P
></DIV
>


The length of zs is the minimum of the lengths of xs and ys and each
element z in zs is f(x, y), where x and y are the corresponding elements in
xs and ys, respectively.  Clearly, this implementation of
<FONT
COLOR="RED"
>list0_zipwith</FONT
> is not tail-recursive.  Note that
<FONT
COLOR="RED"
>list0_zipwith</FONT
> behaves exactly like <FONT
COLOR="RED"
>list0_zip</FONT
> if its
third argument <FONT
COLOR="RED"
>f</FONT
> is replaced with <FONT
COLOR="RED"
>lam (x, y) =&#62; @(x, y)</FONT
>.
This function template is also named <FONT
COLOR="RED"
>list0_map2</FONT
> for the obvious
reason.
</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x1210.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x1328.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Polymorphic Datatypes</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c1121.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Example: Mergesort on Lists</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>