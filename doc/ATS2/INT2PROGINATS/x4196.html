<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>メモリの確保と解放</TITLE
><META
CHARSET="UTF-8"><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="ATSプログラミング入門"
HREF="book1.html"><LINK
REL="UP"
TITLE="抽象観と観型 (viewtype)"
HREF="c4144.html"><LINK
REL="PREVIOUS"
TITLE="抽象観と観型 (viewtype)"
HREF="c4144.html"><LINK
REL="NEXT"
TITLE="例: 配列を用いたリングバッファ"
HREF="x4260.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="./assets/INT2PROGINATS-BOOK.css"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>ATSプログラミング入門: </TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c4144.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 16. 抽象観と観型 (viewtype)</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x4260.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="memory-allocation-deallocation"
>メモリの確保と解放</A
></H1
><P
>&#13;メモリの確保と解放にまつわる問題は、実行時のガベージコレクション (GC)
が許されないシステムプログラミングにおいて最重要です。
メモリ管理を安全にかつ効率よく扱うことは、プログラミングの挑戦において長期にわたる未解決問題です。
そして ATS におけるその新しい解決策は、定理証明によるプログラミング (PwTP) のパラダイムに堅く根差しています。

</P
><P
>&#13;次の関数 <FONT
COLOR="RED"
>malloc_gc</FONT
> がメモリ確保のために ATS では用意されています:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4201"
></A
><PRE
CLASS="programlisting"
>fun malloc_gc
  {n:nat}(n: size_t n)
  : [l:agz] (b0ytes n @ l, mfree_gc_v (l) | ptr l)
// end of [malloc_gc]
</PRE
><P
></P
></DIV
>


種 <FONT
COLOR="RED"
>agz</FONT
> は NULL でないアドレスとして定義されたサブセット種です:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4204"
></A
><PRE
CLASS="programlisting"
>sortdef agz = {a:addr | a &#62; null} // [gz] for great-than-zero
</PRE
><P
></P
></DIV
>


整数 N が与えられた時、
型 <FONT
COLOR="RED"
>b0ytes(N)</FONT
> は N バイトの未初期化の配列を表わす <FONT
COLOR="RED"
>@[byte?][N]</FONT
> の略記です
従って、駐観 <FONT
COLOR="RED"
>b0ytes(N)@L</FONT
> は L をメモリ位置とすると、配列観
<FONT
COLOR="RED"
>array_v(byte?, L, N)</FONT
> と同じです。
観コンストラクタ <FONT
COLOR="RED"
>mfree_gc_v</FONT
> は抽象的です。
与えられた位置 L について、観 <FONT
COLOR="RED"
>mfree_gc_v(L)</FONT
> は次の関数 <FONT
COLOR="RED"
>mfree_gc</FONT
> によって解放されるべき位置 L に確保したメモリを許可する能力を表わします:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4213"
></A
><PRE
CLASS="programlisting"
>fun mfree_gc
  {l:addr}{n:nat}
  (pfat: b0ytes(n) @ l, pfgc: mfree_gc_v (l) | p: ptr l): void
// end of [free_gc]
</PRE
><P
></P
></DIV
>


今まで紹介してきた中では、<FONT
COLOR="RED"
>mfree_gc_v(L)</FONT
> はどのような駐観の上にも構築されていないはじめての観の形であることに注意してください。

</P
><P
>&#13;実際には、バイト数を直接扱うのはいくぶん面倒です。
(ある型の) 単一の値を保管するメモリを確保する関数 <FONT
COLOR="RED"
>ptr_alloc</FONT
> と、そのようなメモリを解放する関数
<FONT
COLOR="RED"
>ptr_free</FONT
> が用意されています:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4219"
></A
><PRE
CLASS="programlisting"
>fun{a:vt0p}
ptr_alloc ()
  :&#60;&#62; [l:agz] (a? @ l, mfree_gc_v (l) | ptr l)
// end of [ptr_alloc]

fun ptr_free
  {a:t@ype}{l:addr}
  (pfgc: mfree_gc_v (l), pfat: a @ l | p: ptr l):&#60;&#62; void = "mac#%"
// end of [ptr_free]
</PRE
><P
></P
></DIV
>


さらに、(ある型の) 値の配列を格納するメモリを確保する関数 <FONT
COLOR="RED"
>array_ptr_alloc</FONT
>
と、そのようなメモリを解放する関数 <FONT
COLOR="RED"
>array_ptr_free</FONT
> があります:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4223"
></A
><PRE
CLASS="programlisting"
>fun{a:vt0p}
array_ptr_alloc
  {n:int}
(
  asz: size_t n
) : [l:agz]
(
  array_v (a?, l, n), mfree_gc_v (l) | ptr l
) // end of [array_ptr_alloc]

fun{}
array_ptr_free
  {a:vt0p}{l:addr}{n:int}
(
  array_v (a?, l, n), mfree_gc_v (l) | ptr l
) : void // end of [array_ptr_free]
</PRE
><P
></P
></DIV
>


</P
><P
>&#13;ここで配列の確保と解放の両方を必要とする現実的で興味深い例を紹介します。
次の2つの関数テンプレート <FONT
COLOR="RED"
>msort1</FONT
> と <FONT
COLOR="RED"
>msort2</FONT
> は与えられた配列をマージソートします:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4228"
></A
><PRE
CLASS="programlisting"
>typedef cmp (a:t@ype) = (&#38;a, &#38;a) -&#62; int

extern
fun{
a:t@ype
} msort1 {n:nat}
  (A: &#38;(@[a][n]), n: size_t n, B: &#38;(@[a?][n]), cmp: cmp(a)): void
// end of [msort1]

extern
fun{
a:t@ype
} msort2 {n:nat}
  (A: &#38;(@[a][n]), n: size_t n, B: &#38;(@[a?][n]) &#62;&#62; @[a][n], cmp: cmp(a)): void
// end of [msort2]
</PRE
><P
></P
></DIV
>


与えられた配列の2つのソート済み部分をマージするには追加領域が必要になることがよく知られています。
<FONT
COLOR="RED"
>msort1</FONT
> が配列 A と B に対して呼び出された時、配列 A はソートされる対象で、配列 B
は (ソート済みの配列の領域の) マージを行なうのに必要なスクラッチ領域の一種です。
<FONT
COLOR="RED"
>msort1</FONT
> 呼び出しが返ると、A のソートされたバージョンはまだ A に保管されています。
<FONT
COLOR="RED"
>msort2</FONT
> が行なうことも同様ですが、<FONT
COLOR="RED"
>msort2</FONT
> 呼び出しが返ると A のソートされたバージョンは
B に保管されます。
興味を持った読者には、良い練習問題として <FONT
COLOR="RED"
>msort1</FONT
> と <FONT
COLOR="RED"
>msort2</FONT
>
の相互再帰的な実装をしてみることをおすすめします。
<FONT
COLOR="RED"
>msort1</FONT
> を用いたマージソートの実装は次のようにたやすく与えることができます:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4237"
></A
><PRE
CLASS="programlisting"
>extern
fun{
a:t@ype
} mergeSort{n:nat}
  (A: &#38;(@[a][n]), n: size_t n, cmp: cmp(a)): void
// end of [mergeSort]

implement
{a}(*tmp*)
mergeSort (A, n, cmp) = let
  val (pfat, pfgc | p) = array_ptr_alloc&#60;a&#62; (n)
  val ((*void*)) = msort1 (A, n, !p, cmp)
  val ((*void*)) = array_ptr_free (pfat, pfgc | p)
in
  // nothing
end // end of [mergeSort]
</PRE
><P
></P
></DIV
>


明確に、配列は (スクラッチ領域として使われるために) はじめに確保され、それからもはや使わなくなった後に解放されます。

</P
><P
>&#13;また、特殊な関数 <FONT
COLOR="RED"
>alloca</FONT
> を呼び出すことでコールスタックにメモリを確保する関数も作ることができます。それには ATS では次のような型が与えられます:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4241"
></A
><PRE
CLASS="programlisting"
>(*
staload "libc/SATS/alloa.sats"
*)
fun alloca
  {dummy:addr}{n:int} (
  pf: void@dummy | n: size_t (n)
) : [l:addr] (bytes(n) @ l, bytes(n) @ l -&#62; void@dummy | ptr(l))
</PRE
><P
></P
></DIV
>


<FONT
COLOR="RED"
>alloca</FONT
> に割り当てられた型は、型付けされた ATS コードが <FONT
COLOR="RED"
>alloca</FONT
> 関数呼び出しが返った後に誤ってその関数呼び出しから得られたメモリにアクセスすることを防止します。

</P
><P
>&#13;次の関数 <FONT
COLOR="RED"
>array_ptr_alloca_tsz</FONT
> は動的には <FONT
COLOR="RED"
>alloca</FONT
> と同じです。しかしより便利な型が付けられています:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4248"
></A
><PRE
CLASS="programlisting"
>fun
array_ptr_alloca_tsz
  {a:vt0p}{dummy:addr}{n:int}
(
  pf: void@dummy | asz: size_t(n), tsz: sizeof_t(a)
) : [l:addr] (array(a?,n)@l, array(a?,n)@l -&#62; void@dummy | ptr(l))
</PRE
><P
></P
></DIV
>


例として、上記で実装された関数テンプレート <FONT
COLOR="RED"
>mergeSort</FONT
> 次のように実装することもできます:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN4251"
></A
><PRE
CLASS="programlisting"
>implement
{a}(*tmp*)
mergeSort (A, n, cmp) = let
  val tsz = sizeof&#60;a&#62;
  var dummy: void = ()
  prval pf = view@dummy
  val (
    pfat, fpfat | p
  ) = array_ptr_alloca_tsz{a}(pf | n, tsz)
  val ((*void*)) = msort1&#60;a&#62; (A, n, !p, cmp)
  prval ((*void*)) = view@dummy := fpfat (pfat)
in
  // nothing
end // end of [mergeSort]
</PRE
><P
></P
></DIV
>


ここではマージを行なうのに必要なスクラッチ領域として使われる配列を <FONT
COLOR="RED"
>mergeSort</FONT
> のコールスタックに確保しています。この <FONT
COLOR="RED"
>mergeSort</FONT
> の実装は興味深いものですが、実際には以前の実装より劣っています。大きなメモリチャンクを確保する <FONT
COLOR="RED"
>alloca</FONT
> 呼び出しはクラッシュをたやすく引き起こし、その原因を見つけ出すのはしばしば困難です。一般に、<FONT
COLOR="RED"
>malloc</FONT
> よりも <FONT
COLOR="RED"
>alloca</FONT
> を使うことは正当化しずらく、後者に対する呼び出しは綿密に精査すべきです。

</P
><P
>&#13;配列に対するマージソートの実装全体とテストコードは
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/INT2PROGINATS/CODE/CHAP_ABSVTYPE/mergeSort.dats"
TARGET="_top"
>オンライン</A
>
から入手できます。

</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c4144.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x4260.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>抽象観と観型 (viewtype)</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c4144.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>例: 配列を用いたリングバッファ</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>