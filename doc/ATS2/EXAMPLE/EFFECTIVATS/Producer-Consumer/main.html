

<!DOCTYPE html>
<html>

<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />


<title>EFFECTIVATS: 生産者/消費者問題</title>

<style type="text/css">
  .patsyntax {color:#808080;background-color:#E0E0E0;}
  .patsyntax span.keyword {color:#000000;font-weight:bold;}
  .patsyntax span.comment {color:#787878;font-style:italic;}
  .patsyntax span.extcode {color:#A52A2A;}
  .patsyntax span.neuexp  {color:#800080;}
  .patsyntax span.staexp  {color:#0000F0;}
  .patsyntax span.prfexp  {color:#603030;}
  .patsyntax span.dynexp  {color:#F00000;}
  .patsyntax span.stalab  {color:#0000F0;font-style:italic}
  .patsyntax span.dynlab  {color:#F00000;font-style:italic}
  .patsyntax span.dynstr  {color:#008000;font-style:normal}
  .patsyntax span.stacstdec  {text-decoration:none;}
  .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}
  .patsyntax span.dyncstdec  {text-decoration:none;}
  .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}
  .patsyntax span.dyncst_implement  {color:#B80000;text-decoration:underline;}
</style>

<style type="text/css">
  @import url("https://fonts.googleapis.com/css?family=Lato:400,300,700");

  body {
    margin: 0 auto;
    width: 50%;
    font-family: "Lato", sans-serif;
    font-weight: 400;
    font-size: 15pt;
    color: #2E2E2E;
    padding-left: 2em;
    padding-right: 2em;
    border-left: 1px solid #acacac;
    border-right: 1px solid #acacac;
  }
  pre, .patsyntax {
    color: black;
    background-color: #FEFFEC;
    border: 1px solid #acacac;
    border-left: 5px solid #BCBCBC;
    padding: 20px;
    margin: 1.5em 0;
    font-family: monospace;
    font-size: 0.75em;
    overflow: auto;
    line-height: 1.3em;
  }
  h1, h2, h3 {
    font-family: "Lato", sans-serif;
  }
  h1 {
    border: 1px solid #8c8c8c;
    font-size: 1.2em;
    padding: 5px;
    background-color: #EEF;
    box-shadow: 1px 1px 2px #999;
    text-align: center;
  }
  h2 {
    border-bottom: 1px solid #8C8C8C;
    padding: 5px;
    margin-top: 1em;
    font-size: 1.2em;
    text-align: left;
  }
  h4 {
    border-bottom: 1px dashed #8C8C8C;
  }
  ol, ul {
    list-style: none;
    padding-left: 0;
  }
  li:first-child {
    border-top: 1px solid #EEF;
  }
  li:hover {
    background-color: #EEF;
  }
  li {
    border-bottom: 1px solid #EEF;
    border-left: 1px solid #EEF;
    border-right: 1px solid #EEF;
  }
  li a {
    display: inline-block;
    width: 100%;
    height: 100%;
    padding: 5px;
  }

  a:hover {
    color: black;
  }
  a:visited {
    color: #7D7D7D;
  }
  a {
    text-decoration: none;
    color: #0062BB;
  }

  @media print {
  body {
    margin: 0 auto;
    width: 90%;
    font-size: 12pt;
    border-left: 0;
    border-right: 0;
  }
  pre, .patsyntax {
    color: black;
    padding: 10px;
    font-size: 10pt;
  }
  h1 {
    box-shadow: none;
  }
  }
</style>

</head>

<body>

<h1>


Effective ATS:<br>
生産者/消費者問題

</h1>



生産者/消費者問題は並行プログラミングにおける古典的な問題です。
この記事では、依存型と線形型を効果的に使った、この問題に対する実装を紹介しようと思います。
並行プログラムをデバッグすることがとてつもなく困難なため、バグの検出と修正を静的な検査に頼ることは、逐次実行プログラミングよりも並行プログラミングにおいてさらに重要になります。
ここで紹介するプログラミングのスタイルは習得するのに時間がかかるかもしれませんが、その大きな利点はすぐに評価できるでしょう。
一般的に、動的なテストが難しい文脈において、ATS はより異彩を放っています。


<h2>


この問題についての解説

</h2>



有限容量のバッファが与えられたとき、そのバッファに要素を挿入する複数の生産者と、そのバッファから要素を取り出す複数の消費者がいます。
もし生産者が要素を挿入しようとしたけれどバッファが満杯であったなら、バッファが満杯でなくなるまでその生産者はブロックします。
もし消費者が要素を取り出そうとしたけれどバッファが空であったなら、バッファが空でなくなるまでその消費者はブロックします。


<h2>


線形バッファのインターフェイス

</h2>



はじめに次のようにバッファを表わす線形抽象型を宣言しましょう:


<pre
class="patsyntax">
<span class="comment">//</span>
<span class="staexp"><span class="keyword">absvtype</span>
buffer_vtype <span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">vt@ype+</span><span class="keyword">,</span> m<span class="keyword">:</span>int<span class="keyword">,</span> n<span class="keyword">:</span> int<span class="keyword">)</span> <span class="keyword">=</span> ptr</span>
<span class="comment">//</span>
<span class="keyword">vtypedef</span>
<span class="staexp">buffer <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="staexp">buffer_vtype</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="keyword">vtypedef</span>
<span class="staexp">buffer <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">,</span> <span class="staexp">m<span class="keyword">:</span>int</span><span class="keyword">,</span> <span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">buffer_vtype</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</pre>



型 T と2つの整数 M, N が与えられたとき、型 [buffer(T, M, N)]
は型 T の要素が N 個保存された容量 M のバッファを表わします。
次の補題 (lemma) は (制約解決を目的として) M >= N かつ N >= 0
という特性を成立させるために使うことができます:


<pre
class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span>
lemma_buffer_param<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="keyword">(</span><span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>m &gt;= n<span class="keyword">;</span> n &gt;= 0<span class="keyword">]</span></span> <span class="staexp">void</span></span>
</pre>



関数 [buffer_make_nil] は要素を含まない与えられた容量の線形バッファを生成することができます:


<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
buffer_make_nil<span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>pos<span class="keyword">}</span></span> <span class="keyword">(</span>cap<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">m</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">buffer</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span></span>
</pre>



関数 [buffer_isnil] と [buffer_isful] は与えられたバッファがそれぞれ空なのか、満杯なのかを判定できます:


<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> buffer_isnil<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">(</span><span class="staexp">n</span><span class="staexp">==</span><span class="staexp">0</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">fun</span> buffer_isful<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">(</span><span class="staexp">m</span><span class="staexp">==</span><span class="staexp">n</span><span class="keyword">)</span></span>
</pre>



関数 [buffer_insert] は満杯でないバッファに要素を挿入します:


<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
buffer_insert<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n <span class="keyword">&lt;</span> m<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">buffer</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [buffer_insert]</span>
</pre>



関数 [buffer_takeout] は空でないバッファから要素を取り出します:


<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
buffer_takeout<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n <span class="keyword">&gt;</span> 0<span class="keyword">}</span></span>
  <span class="keyword">(</span>buf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">buffer</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
</pre>

<h2>


共有バッファのインターフェイス

</h2>



実装の観点から、共有バッファは保護メカニズムで線形バッファを包みます。
このメカニズムは1つの mutex と2つの条件変数から成り立っています。
この mutex は線形バッファを保護するために、この条件変数はビジーウェイトを回避するために導入されています。
この保護メカニズムについて後でより詳細に説明します。


<p>



ここで、共有バッファを表わす抽象型を導入してみましょう:


<pre
class="patsyntax">
<span class="comment">//</span>
<span class="staexp"><span class="keyword">abstype</span>
sbuffer_type <span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">vt@ype</span><span class="keyword">)</span> <span class="keyword">=</span> ptr</span>
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">sbuffer <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">sbuffer_type</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</pre>



[sbuffer] は非線形の型であることに注意してください。
これは、共有バッファは生成された後では明示的に解放することができないことを意味しています。
共有バッファを解放できるように、参照カウントの線形型で [sbuffer] を作ることも可能です。
興味のある読者にはこの別設計に挑戦してみることをおすすめします。
これはわずかに複雑な実装になるはずです。


<p>



線形バッファが与えられたとき、[sbuffer_make_buffer] は
(保護メカニズムで包むことで) それを共有バッファに変えます:


<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sbuffer_make_buffer <span class="keyword">(</span><span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">sbuffer</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
</pre>



関数 [sbuffer_insert] は共有バッファへ要素を挿入にします:


<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sbuffer_insert <span class="keyword">(</span><span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// called by producer</span>
</pre>



[sbuffer_insert] 呼び出しは、共有バッファ中の線形バッファが満杯であるためにブロックする可能性があることに注意してください。


<p>



関数 [sbuffer_takeout] は共有バッファから要素を取り出します:


<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sbuffer_takeout <span class="keyword">(</span>sbuf<span class="keyword">:</span> <span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span> <span class="comment">// called by consumer</span>
</pre>



[sbuffer_takeout] 呼び出しは、共有バッファ中の線形バッファが空であるためにブロックする可能性があることに注意してください。


<h2>


共有バッファの実装

</h2>



共有バッファ中の線形バッファは mutex によって保護されています。


<p>



関数 [sbuffer_acquire] は与えられた共有バッファ中の線形バッファを獲得します:


<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> sbuffer_acquire<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> <span class="keyword">(</span>sbuf<span class="keyword">:</span> <span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">buffer</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
</pre>



関数 [sbuffer_release] は
(線形バッファを獲得したときと同じ共有バッファに)
線形バッファを手放します:


<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
sbuffer_release<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> <span class="keyword">(</span>sbuf<span class="keyword">:</span> <span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> buf<span class="keyword">:</span> <span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
</pre>



ここで、次のような2つの関数を宣言しましょう:


<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sbuffer_insert2 <span class="keyword">(</span><span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sbuffer_takeout2 <span class="keyword">(</span>sbf<span class="keyword">:</span> <span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> buf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
</pre>



関数 [sbuffer_insert2] を呼び出すと、与えられた線形バッファに要素を挿入しようと試みます。
線形バッファが満杯であった場合、線形バッファが満杯でなくなるまで条件変数を待ち合わせるために呼び出し元はブロックします。


<p>



関数 [sbuffer_takeout2] を呼び出すと、与えられた線形バッファから要素を取り出そうと試みます。
線形バッファが空であった場合、線形バッファが空でなくなるまで条件変数を待ち合わせるために呼び出し元はブロックします。


<p>



[sbuffer_insert] と [sbuffer_takeout] はそれぞれ [sbuffer_insert2] と [sbuffer_takeout2] を用いて素直に実装できます:


<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
sbuffer_insert <span class="keyword">(</span>sbuf<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">{</span>
  <span class="dynexp"><span class="keyword">val</span> buf <span class="keyword">=</span> sbuffer_acquire <span class="keyword">(</span>sbuf<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> sbuffer_insert2 <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">,</span> x<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> sbuffer_release <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">)</span></span>
<span class="keyword">}</span></span>

<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
sbuffer_takeout <span class="keyword">(</span>sbuf<span class="keyword">)</span> <span class="keyword">=</span> x <span class="keyword">where</span>
<span class="keyword">{</span>
  <span class="dynexp"><span class="keyword">val</span> buf <span class="keyword">=</span> sbuffer_acquire <span class="keyword">(</span>sbuf<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> x<span class="comment">(*a*)</span> <span class="keyword">=</span> sbuffer_takeout2 <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> sbuffer_release <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">)</span></span>
<span class="keyword">}</span></span>
</pre>



共有バッファの中には2つの条件変数があります。
それらの1つは (共有バッファ中の) 線形バッファが空である条件を扱うためのものです。
もう1つは線形バッファが満杯である条件を扱うためのものです。
次の関数群はこれら2つの条件変数を直接用いて実装されています:


<pre
class="patsyntax">
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
sbuffer_wait_isnil
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">fun</span>
sbuffer_signal_isnil<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>sbuf<span class="keyword">:</span> <span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
sbuffer_wait_isful
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">fun</span>
sbuffer_signal_isful<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>sbuf<span class="keyword">:</span> <span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
</pre>



関数 [sbuffer_wait_isnil] に割り当てられた型は、呼び出す時に呼び出し元が線形バッファの所有者でなければならないこと、呼び出しが返る時にやはりその呼び出し元が空の可能性がある線形バッファの所有者でなければならないこと、を意味しています。
[sbuffer_wait_isnil] 呼び出しが返る時にも線形バッファを所有すべき理由は、
他の呼び出し元 (消費者) がより早くその線形バッファへのアクセス権を獲得してしまう可能性があるためです。


<p>



関数 [sbuffer_wait_isful] に割り当てられた型も同様に説明できます。


<p>

<h4>


[sbuffer_insert2] を実装する

</h4>



[sbuffer_insert2] の実装は次のようになります:


<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
sbuffer_insert2
  <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> isful <span class="keyword">=</span> buffer_isful <span class="keyword">(</span>buf<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> lemma_buffer_param <span class="keyword">(</span>buf<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span> isful
  <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
      sbuffer_wait_isful <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">)</span></span>
    <span class="comment">// end of [val]</span>
  <span class="keyword">in</span>
    sbuffer_insert2 <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">,</span> x<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [then]</span>
  <span class="keyword">else</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> isnil <span class="keyword">=</span> buffer_isnil <span class="keyword">(</span>buf<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> buffer_insert <span class="keyword">(</span>buf<span class="keyword">,</span> x<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> isnil <span class="keyword">then</span> sbuffer_signal_isnil <span class="keyword">(</span>sbuf<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">in</span>
    <span class="comment">// nothing</span>
  <span class="keyword">end</span></span> <span class="comment">// end of [else]</span>
<span class="comment">//  </span>
<span class="keyword">end</span></span> <span class="comment">// end of [sbuffer_insert2]</span>
</pre>



このコードは自明でしょう。
空のバッファに要素を挿入するには、バッファが空である条件を扱う条件変数にシグナルを送る必要があることに注意してください。
もしこれを行なわないと、決して起こされない条件変数をを待ち合わせる消費者によってデッドロックが発生する可能性があります。


<h4>


[sbuffer_takeout2] を実装する

</h4>

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
sbuffer_takeout2
  <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> isnil <span class="keyword">=</span> buffer_isnil <span class="keyword">(</span>buf<span class="keyword">)</span></span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> lemma_buffer_param <span class="keyword">(</span>buf<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span> isnil
  <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
      sbuffer_wait_isnil <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">)</span></span>
    <span class="comment">// end of [val]</span>
  <span class="keyword">in</span>
    sbuffer_takeout2 <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [then]</span>
  <span class="keyword">else</span> x <span class="keyword">where</span>
  <span class="keyword">{</span>
    <span class="dynexp"><span class="keyword">val</span> isful <span class="keyword">=</span> buffer_isful <span class="keyword">(</span>buf<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> x<span class="comment">(*a*)</span> <span class="keyword">=</span> buffer_takeout <span class="keyword">(</span>buf<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> isful <span class="keyword">then</span> sbuffer_signal_isful <span class="keyword">(</span>sbuf<span class="keyword">)</span></span>
  <span class="keyword">}</span> <span class="comment">(* end of [else] *)</span>
<span class="comment">//  </span>
<span class="keyword">end</span></span> <span class="comment">// end of [sbuffer_takeout2]</span>
</pre>



このコードも自明でしょう。
満杯のバッファから要素を取り出すには、バッファが満杯である条件を扱う条件変数にシグナルを送る必要があることに注意してください。
もしこれを行なわないと、決して起こされない条件変数をを待ち合わせる生産者によってデッドロックが発生する可能性があります。


<h4>


残りの実装について

</h4>



生産者/消費者問題の残りの実装は
(pthread がサポートしている mutex と条件変数を用いて)
C言語によってすぐに作ることができます。
例えば、[sbuffer] は次の構造体型の値へのポインタとして表現できます:


<pre>
struct
{
  void *buffer ;
  mutex_t mutex ;
  cond_t CVisnil ;
  cond_t CVisful ;
}
</pre>



直接C言語でコーディングする代わりに、私の実装の残りを ATS
で書くこともできますが、安全でないプログラミングの機能を全面的に使うことになります。
このコードの全体はファイル sbuffer.sats と sbuffer.dats から入手できます。
実装の正確さに自信があるので、私の実装にはテストコードがありません。
ATS でプログラミングをする主要な理由は、意図通りにコードが実行されるのか自分を納得させるために ATS の型を効果的に使えることです。
今回の場合はそれができたと感じています。


<h2>


共有リソースを共なう安全なプログラミング

</h2>



この記事の残りでは、上記で説明した生産者/消費者問題を一般化したような、共有リソースを共なう安全なプログラミングに対する一般的なアプローチの要点を説明しようと思います。


<p>



共有しようとしている値のために線形型 [Resource] を想像してみましょう:


<pre
class="patsyntax">
<span class="staexp"><span class="keyword">absvtype</span> Resource</span>
</pre>



なんらかの保護メカニズムで型 [Resource] の線形値を包んで作られる値のために (非線形な) 型 [SharedResource] を導入してみましょう:


<pre
class="patsyntax">
<span class="staexp"><span class="keyword">abstype</span> SharedResource</span>
</pre>



その包む行為をする関数は次のような型になるでしょう:


<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> SharedResource_create <span class="keyword">(</span>R<span class="keyword">:</span> <span class="staexp">Resource</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">SharedResource</span></span>
</pre>



共有リソースの中にある線形なリソースはロックによって保護されています。
そして次の2つは線形リソースを取り出す関数と、それを戻す関数です:


<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> SharedResource_acquire <span class="keyword">(</span>SR<span class="keyword">:</span> <span class="staexp">SharedResource</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Resource</span></span>
<span class="dynexp"><span class="keyword">fun</span> SharedResource_release <span class="keyword">(</span>SR<span class="keyword">:</span> <span class="staexp">SharedResource</span><span class="keyword">,</span> R<span class="keyword">:</span> <span class="staexp">Resource</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
</pre>



ここで、線形リソースを処理する次の関数があると仮定してみましょう:


<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> Resource_process <span class="keyword">(</span>R<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Resource</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span>
</pre>



[Resource_process] 呼び出しが true を返したら、そのリソースは適切に処理されています。
そうでなければ、処理する前にそのリソースの状態を変更する必要があることを示していることになります。


<p>



私達が実装したいのは次の関数です:


<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> SharedResource_process <span class="keyword">(</span>SR<span class="keyword">:</span> <span class="staexp">SharedResource</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
</pre>



共有リソースに対して呼び出されると、[SharedResource_process] は [Resource_process]
を呼び出して、その内にある線形リソースを処理しようと試みます。


<p>



[SharedResource_process] の実装は次のような概略になります:


<pre
class="patsyntax">
<span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span>
SharedResource_wait
  <span class="keyword">(</span>SR<span class="keyword">:</span> <span class="staexp">SharedResource</span><span class="keyword">,</span> R<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Resource</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span>
SharedResource_process2
  <span class="keyword">(</span>SR<span class="keyword">:</span> <span class="staexp">SharedResource</span><span class="keyword">,</span> R<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Resource</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
SharedResource_process
  <span class="keyword">(</span>SR<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">where</span>
<span class="keyword">{</span>
  <span class="dynexp"><span class="keyword">val</span> R <span class="keyword">=</span> SharedResource_acquire <span class="keyword">(</span>SR<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> SharedResource_process2 <span class="keyword">(</span>SR<span class="keyword">,</span> R<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> SharedResource_release <span class="keyword">(</span>SR<span class="keyword">,</span> R<span class="keyword">)</span></span>
<span class="keyword">}</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
SharedResource_process2
  <span class="keyword">(</span>SR<span class="keyword">,</span> R<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> ans <span class="keyword">=</span> Resource_process <span class="keyword">(</span>R<span class="keyword">)</span></span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span> ans
  <span class="keyword">then</span>
  <span class="keyword">(</span>
    <span class="comment">// processing is done properly</span>
    <span class="comment">// there may be a need to send signals</span>
    <span class="comment">// to some conditional variables</span>
  <span class="keyword">)</span>
  <span class="keyword">else</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
      SharedResource_wait <span class="keyword">(</span>SR<span class="keyword">,</span> R<span class="keyword">)</span></span>
    <span class="comment">// end of [val]</span>
  <span class="keyword">in</span>
    SharedResource_process2 <span class="keyword">(</span>SR<span class="keyword">,</span> R<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [else]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [SharedResource_process2]</span>
<span class="comment">//</span>
</pre>



[SharedResource_wait] 呼び出しは、ビジーウェイトを回避するなんらかの条件変数の待ち行列にその呼び出し元を置きます。
処理を行なう [Resource_process] に必要な条件が満たされた時はいつでも、その条件変数に
(別の呼び出し元によって) シグナルを送らねければなりません。


<p>



この記事で示したコードの全体はファイル SharedResource.dats から入手できます。


<hr size="2">



この記事は
<a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>
によって書かれ、
<a href="http://jats-ug.metasepi.org/">Japan ATS User Group</a>
によって翻訳されています。


<script type="text/javascript">
  window.onload = function() {
    var links = [];
    var headers = document.getElementsByTagName('h2');

    for (var i = 0; i < headers.length; i++) {
        var header = headers[i];
        var subHeadings = header.getElementsByTagName('h4');
        var title = header.innerHTML;
        var link = title.trim().split(/\s/).map(function(x) { return x.toLowerCase(); }).join('-');
        var html = '<h2 id="' + link + '">' + title + '</h2>';
        var linkHtml = '<a href="#' + link + '">' + html + '</a>';
        header.outerHTML = linkHtml;
        links.push({link: link, title: title});
    }

    if (links.length > 0) {
        var sideBarHtml = '<h2>Table of Contents</h2>';
        sideBarHtml += '<ul class="sidebar-list">';
        for (var i = 0; i < links.length; i++) {
            var link = links[i];
            sideBarHtml += '<li class="sidebar-item">';
            sideBarHtml += '<a href="#' + link.link + '">' + link.title + '</a>';
            sideBarHtml += '</li>';
        }
        sideBarHtml += '</ul>';
        sideBarHtml += '<h2>Introduction</h2>';

        var sidebar = document.createElement('div');
        sidebar.className = 'sidebar';
        sidebar.innerHTML = sideBarHtml

        var mainTitle = document.getElementsByTagName('h1')[0];
        document.body.insertBefore(sidebar, mainTitle.nextSibling);
    }
  }
</script>

</body>
</html>


