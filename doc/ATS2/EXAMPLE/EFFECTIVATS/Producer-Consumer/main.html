

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
   "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<title>EFFECTIVATS-Producer-Consumer</title>
<style type="text/css">
  .patsyntax {color:#808080;background-color:#E0E0E0;}
  .patsyntax span.keyword {color:#000000;font-weight:bold;}
  .patsyntax span.comment {color:#787878;font-style:italic;}
  .patsyntax span.extcode {color:#A52A2A;}
  .patsyntax span.neuexp  {color:#800080;}
  .patsyntax span.staexp  {color:#0000F0;}
  .patsyntax span.prfexp  {color:#603030;}
  .patsyntax span.dynexp  {color:#F00000;}
  .patsyntax span.stalab  {color:#0000F0;font-style:italic}
  .patsyntax span.dynlab  {color:#F00000;font-style:italic}
  .patsyntax span.dynstr  {color:#008000;font-style:normal}
  .patsyntax span.stacstdec  {text-decoration:none;}
  .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}
  .patsyntax span.dyncstdec  {text-decoration:none;}
  .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}
  .patsyntax span.dyncst_implement  {color:#B80000;text-decoration:underline;}
</style>

</head>

<body>

<h1>
Effective ATS: Producer-Consumer
</h1>

The Producer-Consumer problem is a classical one in concurrent programming.
In this article, I present an implementation of this problem that makes
highly effective use of dependent types and linear types.  Due to great
difficulty in debugging concurrent programs, relying on static checking to
detect and fix bugs is of much more significance in concurrent programing
than in sequential programming.  While the style of programming I employ
here may take time for one to master, the great advantages it brings can be
readily appreciated. In general, ATS shines much more brightly in contexts
where dynamic testing becomes more difficult to perform and/or control.

<h2>
Description of the Problem 
</h2>

Given a buffer of finite capacity, there are multiple producers who insert
items into the buffer and also multiple consumers who take out items from
the buffer. If a producer wants to insert an item but the buffer is full,
the producer is blocked until the buffer becomes not full. If a consumer
wants to take out an item but the buffer is empty, then the consumer is
blocked until the buffer is not empty.

<h2>
Interface for Linear Buffer
</h2>

Let us first declare as follows a linear abstract type for buffers:

<pre
class="patsyntax">
<span class="comment">//</span>
<span class="staexp"><span class="keyword">absvtype</span>
buffer_vtype <span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">vt@ype+</span><span class="keyword">,</span> m<span class="keyword">:</span>int<span class="keyword">,</span> n<span class="keyword">:</span> int<span class="keyword">)</span> <span class="keyword">=</span> ptr</span>
<span class="comment">//</span>
<span class="keyword">vtypedef</span>
<span class="staexp">buffer <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="staexp">buffer_vtype</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="keyword">vtypedef</span>
<span class="staexp">buffer <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">,</span> <span class="staexp">m<span class="keyword">:</span>int</span><span class="keyword">,</span> <span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">buffer_vtype</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</pre>

Given a type T and two integers M and N, the type [buffer(T, M, N)] is for
a buffer of capacity M in which N elements of the type T are stored.  The
following lemma can be used to establish the property that M >= N and N >=
0 (for the purpose of constraint-solving):

<pre
class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span>
lemma_buffer_param<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="keyword">(</span><span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>m &gt;= n<span class="keyword">;</span> n &gt;= 0<span class="keyword">]</span></span> <span class="staexp">void</span></span>
</pre>

The function [buffer_make_nil] can be called to create a linear buffer of a
given capacity that contains no elements:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
buffer_make_nil<span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>pos<span class="keyword">}</span></span> <span class="keyword">(</span>cap<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">m</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">buffer</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span></span>
</pre>

The functions [buffer_isnil] and [buffer_isful] can be called to test
whether a given buffer is empty and full, respectively:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> buffer_isnil<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">(</span><span class="staexp">n</span><span class="staexp">==</span><span class="staexp">0</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">fun</span> buffer_isful<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span> <span class="keyword">(</span><span class="staexp">m</span><span class="staexp">==</span><span class="staexp">n</span><span class="keyword">)</span></span>
</pre>

The function [buffer_insert] is for inserting an element into
a buffer that is not full:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
buffer_insert<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n <span class="keyword">&lt;</span> m<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">buffer</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [buffer_insert]</span>
</pre>

The function [buffer_insert] is for taking out an element from
a buffer that is not empty:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
buffer_takeout<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n <span class="keyword">&gt;</span> 0<span class="keyword">}</span></span>
  <span class="keyword">(</span>buf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">buffer</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
</pre>

<h2>
Interface for Shared Buffer
</h2>

In terms of implementation, a shared buffer wraps a protection mechanism
around a linear buffer that consists of a mutex and two conditional
variables. The mutex is for protecting the linear buffer and the
conditional variables are introduced to avoid busy-waiting. I will present
more details on the protection mechanism later.

<p>

Let us now introduce an abstract type for shared buffers:

<pre
class="patsyntax">
<span class="comment">//</span>
<span class="staexp"><span class="keyword">abstype</span>
sbuffer_type <span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">vt@ype</span><span class="keyword">)</span> <span class="keyword">=</span> ptr</span>
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">sbuffer <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">sbuffer_type</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</pre>

Please note that [sbuffer] is a non-linear type. This means that a shared
buffer cannot be freed explicitly after its creation. It is also possible
to make [sbuffer] a reference-counted linear type so that a shared buffer
can be freed. The interested reader is encouraged to give this alternative
design a try, which should only lead to slightly more involved implementation.

<p>

Given a linear buffer, [sbuffer_make_buffer] turns it into a shared buffer
(by wrapping a protection mechanism around it):

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sbuffer_make_buffer <span class="keyword">(</span><span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">sbuffer</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
</pre>

The function [sbuffer_insert] inserts an element into
a shared buffer:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sbuffer_insert <span class="keyword">(</span><span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// called by producer</span>
</pre>

Note that a call to [sbuffer_insert] may be blocked due to the linear
buffer inside the shared buffer being full.

<p>

The function [sbuffer_takeout] takes out an element from
a shared buffer:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sbuffer_takeout <span class="keyword">(</span>sbuf<span class="keyword">:</span> <span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span> <span class="comment">// called by consumer</span>
</pre>

Note that a call to [sbuffer_takeout] may be blocked due to the linear
buffer inside the shared buffer being empty.

<h2>
Implementation of Shared Buffer
</h2>

The linear buffer inside a shared buffer is protected by a mutex.

<p>

The function [sbuffer_acquire] is for acquiring the linear buffer inside a
given shared buffer:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> sbuffer_acquire<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> <span class="keyword">(</span>sbuf<span class="keyword">:</span> <span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">buffer</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
</pre>

The function [sbuffer_release] is for releasing a linear buffer (to the
same shared buffer from which the linear buffer was previously acquired):

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> sbuffer_release<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> <span class="keyword">(</span>sbuf<span class="keyword">:</span> <span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> buf<span class="keyword">:</span> <span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
</pre>


Let us now declare two functions as follows:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sbuffer_insert2 <span class="keyword">(</span><span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sbuffer_takeout2 <span class="keyword">(</span>sbf<span class="keyword">:</span> <span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> buf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
</pre>

A call to the function [sbuffer_insert2] tries to insert an element into a
given linear buffer. In the case where the linear buffer is full, the
caller is blocked to wait on some conditional variable until it is notified
that the linear buffer is no longer full.

<p>

A call to the function [sbuffer_takeout2] tries to take out an element from
a given linear buffer. In the case where the linear buffer is empty, the
caller is blocked to wait on some conditional variable until it is notified
that the linear buffer is no longer empty.

<p>

It is straightforward to implement [sbuffer_insert] and [sbuffer_takeout]
based on [sbuffer_insert2] and [sbuffer_takeout2], respectively:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
sbuffer_insert <span class="keyword">(</span>sbuf<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">{</span>
  <span class="dynexp"><span class="keyword">val</span> buf <span class="keyword">=</span> sbuffer_acquire <span class="keyword">(</span>sbuf<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> sbuffer_insert2 <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">,</span> x<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> sbuffer_release <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">)</span></span>
<span class="keyword">}</span></span>

<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
sbuffer_takeout <span class="keyword">(</span>sbuf<span class="keyword">)</span> <span class="keyword">=</span> x <span class="keyword">where</span>
<span class="keyword">{</span>
  <span class="dynexp"><span class="keyword">val</span> buf <span class="keyword">=</span> sbuffer_acquire <span class="keyword">(</span>sbuf<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> x<span class="comment">(*a*)</span> <span class="keyword">=</span> sbuffer_takeout2 <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> sbuffer_release <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">)</span></span>
<span class="keyword">}</span></span>
</pre>

There are two conditional variables (CVs) inside a shared buffer.  One of
them is for handling the condition of the linear buffer (inside the shared
buffer) being empty, and the other CV is for handling the condition of the
linear buffer being full. The following functions are implemented directly
based on these two conditional variables:

<pre
class="patsyntax">
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
sbuffer_wait_isnil
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">fun</span> sbuffer_signal_isnil<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>sbuf<span class="keyword">:</span> <span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
sbuffer_wait_isful
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">fun</span> sbuffer_signal_isful<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>sbuf<span class="keyword">:</span> <span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
</pre>

The type assigned to the function [sbuffer_wait_isnil] means that its
caller must have possession of a linear buffer when calling it and the
caller should still have possession of the linear buffer, which may be
empty, when the call returns. The reason for the linear buffer being still
empty at the moment when a call to [sbuffer_wait_isnil] returns is
that other callers (consumers) may have gained access to the linear buffer
earlier.

<p>

The type assigned to the function [sbuffer_wait_isful] can be
explained similarly.

<p>

<h4>
Implementing [sbuffer_insert2]
</h4>

An implementation of [sbuffer_insert2] is given as follows:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
sbuffer_insert2
  <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> isful <span class="keyword">=</span> buffer_isful <span class="keyword">(</span>buf<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> lemma_buffer_param <span class="keyword">(</span>buf<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span> isful
  <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
      sbuffer_wait_isful <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">)</span></span>
    <span class="comment">// end of [val]</span>
  <span class="keyword">in</span>
    sbuffer_insert2 <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">,</span> x<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [then]</span>
  <span class="keyword">else</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> isnil <span class="keyword">=</span> buffer_isnil <span class="keyword">(</span>buf<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> buffer_insert <span class="keyword">(</span>buf<span class="keyword">,</span> x<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> isnil <span class="keyword">then</span> sbuffer_signal_isnil <span class="keyword">(</span>sbuf<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">in</span>
    <span class="comment">// nothing</span>
  <span class="keyword">end</span></span> <span class="comment">// end of [else]</span>
<span class="comment">//  </span>
<span class="keyword">end</span></span> <span class="comment">// end of [sbuffer_insert2]</span>
</pre>

The code should be self-explaining. Please note that inserting an element
into an empty buffer requires a signal to be sent to the CV handling the
condition of buffer being empty. If this is not done, then a deadlock may
occur as the consumers waiting on the CV can never be awakened.

<h4>
Implementing [sbuffer_takeout2]
</h4>

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
sbuffer_takeout2
  <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> isnil <span class="keyword">=</span> buffer_isnil <span class="keyword">(</span>buf<span class="keyword">)</span></span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> lemma_buffer_param <span class="keyword">(</span>buf<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span> isnil
  <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
      sbuffer_wait_isnil <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">)</span></span>
    <span class="comment">// end of [val]</span>
  <span class="keyword">in</span>
    sbuffer_takeout2 <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [then]</span>
  <span class="keyword">else</span> x <span class="keyword">where</span>
  <span class="keyword">{</span>
    <span class="dynexp"><span class="keyword">val</span> isful <span class="keyword">=</span> buffer_isful <span class="keyword">(</span>buf<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> x<span class="comment">(*a*)</span> <span class="keyword">=</span> buffer_takeout <span class="keyword">(</span>buf<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> isful <span class="keyword">then</span> sbuffer_signal_isful <span class="keyword">(</span>sbuf<span class="keyword">)</span></span>
  <span class="keyword">}</span> <span class="comment">(* end of [else] *)</span>
<span class="comment">//  </span>
<span class="keyword">end</span></span> <span class="comment">// end of [sbuffer_takeout2]</span>
</pre>

The code should be self-explaining. Please note that taking out an element
from a full buffer requires a signal to be sent to the CV handling the
condition of buffer being full. If this is not done, then a deadlock may
occur as the producers waiting on the CV can never be awakened.

<h4>
Summary of the Remaining Implementation
</h4>

The remaining implementation of the producer-consumer problem can be
readily done in C (based on pthread support for mutexes and conditional
variables). For instance, [sbuffer] can be represented as a pointer to
a value of the following struct type:

<pre>
struct
{
  void *buffer ;
  mutex_t mutex ;
  cond_t CVisnil ;
  cond_t CVisful ;
}
</pre>

Instead of being coded in C directly, the rest of my implementation is also
written in ATS but it makes pervasive use of some unsafe programming
features. Please find the entirety of the code in the files sbuffer.sats
and sbuffer.dats. There is no testing code in my implementation as I feel
highly confident about its correctness. A primary reason for programming in
ATS is that one can make effective use of types in ATS so as to convince
oneself that his or her code should perform as expected. I feel that I have
done it in this case.

<h2>
Safe Programming with Shared Resources
</h2>

In the rest of the article, I would like to outline a general approach
to safe programming with shared resources that can be seen as a generalization
of the implementation of the producer-consumer problem presented above.

<p>

Suppose we have a linear type [Resource] for values that we want to share:

<pre
class="patsyntax">
<span class="staexp"><span class="keyword">absvtype</span> Resource</span>
</pre>

Let us introduce a (non-linear) type [SharedResource] for values that are
formed by wrapping some kind of protection mechnism around linear values of
the type [Resource]:

<pre
class="patsyntax">
<span class="staexp"><span class="keyword">abstype</span> SharedResource</span>
</pre>

The function that does the wrapping can be given the following type:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> SharedResource_create <span class="keyword">(</span>R<span class="keyword">:</span> <span class="staexp">Resource</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">SharedResource</span></span>
</pre>

The linear resource inside a shared resource is protected by a lock,
and the following two functions are for taking out the linear resource
and returning it back:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> SharedResource_acquire <span class="keyword">(</span>SR<span class="keyword">:</span> <span class="staexp">SharedResource</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Resource</span></span>
<span class="dynexp"><span class="keyword">fun</span> SharedResource_release <span class="keyword">(</span>SR<span class="keyword">:</span> <span class="staexp">SharedResource</span><span class="keyword">,</span> R<span class="keyword">:</span> <span class="staexp">Resource</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
</pre>

Let us now assume that we have the following function for processing
a linear resource:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> Resource_process <span class="keyword">(</span>R<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Resource</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span>
</pre>

If a call to [Resource_process] returns true, then the resource has been
processed properly. Otherwise, it is an indication that the state of the
resource needs to be changed before it is suitable for processing.

<p>

What we want to implement is the following function:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> SharedResource_process <span class="keyword">(</span>SR<span class="keyword">:</span> <span class="staexp">SharedResource</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
</pre>

When called on a shared resource, [SharedResource_process] tries to process
the linear resource inside it by calling [Resource_process].

<p>

An implementation of [SharedResource_process] is sketched as follows:

<pre
class="patsyntax">
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span> SharedResource_process2 <span class="keyword">(</span>SR<span class="keyword">:</span> <span class="staexp">SharedResource</span><span class="keyword">,</span> R<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Resource</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>

<span class="dynexp"><span class="keyword">implement</span>
SharedResource_process
  <span class="keyword">(</span>SR<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">where</span>
<span class="keyword">{</span>
  <span class="dynexp"><span class="keyword">val</span> R <span class="keyword">=</span> SharedResource_acquire <span class="keyword">(</span>SR<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> SharedResource_process2 <span class="keyword">(</span>SR<span class="keyword">,</span> R<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> SharedResource_release <span class="keyword">(</span>SR<span class="keyword">,</span> R<span class="keyword">)</span></span>
<span class="keyword">}</span></span>

<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span> SharedResource_wait <span class="keyword">(</span>SR<span class="keyword">:</span> <span class="staexp">SharedResource</span><span class="keyword">,</span> R<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Resource</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>

<span class="dynexp"><span class="keyword">implement</span>
SharedResource_process2
  <span class="keyword">(</span>SR<span class="keyword">,</span> R<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> ans <span class="keyword">=</span> Resource_process <span class="keyword">(</span>R<span class="keyword">)</span></span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span> ans
  <span class="keyword">then</span>
  <span class="keyword">(</span>
    <span class="comment">// processing is done properly</span>
    <span class="comment">// there may be a need to send signals</span>
    <span class="comment">// to some conditional variables</span>
  <span class="keyword">)</span>
  <span class="keyword">else</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> SharedResource_wait <span class="keyword">(</span>SR<span class="keyword">,</span> R<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    SharedResource_process2 <span class="keyword">(</span>SR<span class="keyword">,</span> R<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [else]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [SharedResource_process2]</span>
</pre>

A call to [SharedResource_wait] puts the caller on the waiting-list
of some conditional variable to avoid busy-waiting. Whenever the condition
needed for [Resource_process] to do proper processing is met, a signal should
be sent to the conditional variable (by another caller).

<p>

Please find in the file SharedResource.dats the entirety of the code
presented in this section.

<hr size="2">

This article is written by <a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>.

</body>
</html>


