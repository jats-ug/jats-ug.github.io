<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>永続化ハッシュテーブル</TITLE
><META
CHARSET="UTF-8"><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="ATSプログラミングチュートリアル"
HREF="book1.html"><LINK
REL="UP"
TITLE="基本的なチュートリアル"
HREF="p37.html"><LINK
REL="PREVIOUS"
TITLE="サイズを伴う永続化行列"
HREF="c901.html"><LINK
REL="NEXT"
TITLE="末尾再帰"
HREF="c993.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="./assets/ATS2TUTORIAL-BOOK.css"></HEAD
><BODY
CLASS="chapter"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>ATSプログラミングチュートリアル: </TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c901.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c993.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="chapter"
><H1
><A
NAME="hashtable"
></A
>Chapter 20. 永続化ハッシュテーブル</H1
><P
>&#13;ハッシュテーブルは有限写像の実装でよく使われます。
ATSLIB/libats には、linear chaining と linear probing を用いたハッシュテーブル実装があります。
永続化ハッシュテーブルだけでなく線形ハッシュテーブルのサポートもあります。
線形ハッシュテーブルはプログラマの手で安全に解放できます。
(線形ハッシュテーブルを用いた) 永続化ハッシュテーブルはガベージコレクション (GC) によって安全に回収されます。
この章では、永続化ハッシュテーブルの生成と操作方法を示します。
</P
><P
>&#13;型 <FONT
COLOR="RED"
>key_t</FONT
> のキーから型 <FONT
COLOR="RED"
>itm_t</FONT
> の要素へマップする写像が必要だと考えます。
次のコードは本質的に、ATSLIB/libats でのハッシュテーブル実装を用いて、写像の生成と操作を表わすインターフェイスを作っています:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN938"
></A
><PRE
CLASS="programlisting"
>local

typedef
key = key_t and itm = itm_t

in (* in-of-local *)

#include "libats/ML/HATS/myhashtblref.hats"

end // end of [local]
</PRE
><P
></P
></DIV
>


ハッシュテーブルを用いたプログラミングを単純化するためのラッパーである HATS ファイルは
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/ATS-Postiats/libats/ML/HATS/myhashtblref.hats"
TARGET="_top"
>オンライン</A
>
から入手できます。

</P
><P
>&#13;<FONT
COLOR="RED"
>key_t</FONT
> は <FONT
COLOR="RED"
>string</FONT
>、 <FONT
COLOR="RED"
>itm_t</FONT
> は <FONT
COLOR="RED"
>int</FONT
> であると仮定します。
次のコードの行は初期容量が 1000 のハッシュテーブルを生成しています:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN946"
></A
><PRE
CLASS="programlisting"
>val mymap = myhashtbl_make_nil(1000)
</PRE
><P
></P
></DIV
>


この場合の容量とは、生成されたハッシュテーブルに関連する配列のサイズであることに注意してください。
ハッシュテーブル実装の根底は linear chaining に基づいていて、このハッシュテーブルは
5000 (5*1000) 要素までリサイズなしに格納できます。
実際にリサイズが必要な場合も、自動的に行なわれます。
次の数行では、いくつかのキー/要素ペアを <FONT
COLOR="RED"
>mymap</FONT
> に挿入します:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN949"
></A
><PRE
CLASS="programlisting"
>//
val-~None_vt() = mymap.insert("a", 0)
val-~Some_vt(0) = mymap.insert("a", 1)
//
val-~None_vt() = mymap.insert("b", 1)
val-~Some_vt(1) = mymap.insert("b", 2)
//
val-~None_vt() = mymap.insert("c", 2)
val-~Some_vt(2) = mymap.insert("c", 3)
//
</PRE
><P
></P
></DIV
>


ドット表記 <FONT
COLOR="RED"
>.insert</FONT
> は関数 <FONT
COLOR="RED"
>myhashtbl_insert</FONT
> でオーバーロードされています。
キーと要素が与えられたとき、<FONT
COLOR="RED"
>mymap.insert</FONT
> はそのキー/要素ペアを <FONT
COLOR="RED"
>mymap</FONT
> に挿入します。
もし、そのキーが挿入前の写像 <FONT
COLOR="RED"
>mymap</FONT
> の定義域内である場合、そのキーに関連した元の要素が返ります。
そうでない場合、要素は何も返りません。
予想されることですが、<FONT
COLOR="RED"
>mymap</FONT
> のサイズはこの時点で 3 になります:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN957"
></A
><PRE
CLASS="programlisting"
>val () = assertloc (mymap.size = 3)
</PRE
><P
></P
></DIV
>


ドット表記 <FONT
COLOR="RED"
>.size</FONT
> は関数 <FONT
COLOR="RED"
>myhashtbl_get_size</FONT
> によってオーバーロードされており、
この関数は与えれられたハッシュテーブル内に保管されているキー/要素ペアの個数をを返します。
デバッグのために、与えられたハッシュテーブル中のキー/要素ペアを印字したいと思うかもしれません:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN961"
></A
><PRE
CLASS="programlisting"
>//
val () =
  fprintln! (stdout_ref, "mymap = ", mymap)
//
</PRE
><P
></P
></DIV
>


このとき、シンボル <FONT
COLOR="RED"
>fprint</FONT
> は <FONT
COLOR="RED"
>fprint_myhashtbl</FONT
> でオーバーロードされています。
次の2行のコードは、ハッシュテーブルに対して与えられたキーを検索する方法を示しています:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN965"
></A
><PRE
CLASS="programlisting"
>val-~None_vt() = mymap.search("")
val-~Some_vt(1) = mymap.search("a")
</PRE
><P
></P
></DIV
>


ドット表記 <FONT
COLOR="RED"
>.search</FONT
> は関数 <FONT
COLOR="RED"
>myhashtbl_search</FONT
> でオーバーロードされていて、この関数はもし見つかれば与えられたキーに関連した要素を返します。
次の数行のコードは <FONT
COLOR="RED"
>mymap</FONT
> からキー/要素を削除しています:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN970"
></A
><PRE
CLASS="programlisting"
>//
val-true = mymap.remove("a")
val-false = mymap.remove("a")
//
val-~Some_vt(2) = mymap.takeout("b")
val-~Some_vt(3) = mymap.takeout("c")
//
</PRE
><P
></P
></DIV
>


ドット表記 <FONT
COLOR="RED"
>.remove</FONT
> は、与えられたキーのキー/要素ペアを削除する関数 <FONT
COLOR="RED"
>myhashtbl_remove</FONT
> でオーバーロードされています。
もしキー/要素ペアが削除された場合、この関数は true を返します。
そうでない場合、この関数は false を返し、これは与えられたキーに対応するキー/要素ペアが操作するハッシュテーブルに保管されていないことを示しています。
ドット表記 <FONT
COLOR="RED"
>.takeout</FONT
> は関数 <FONT
COLOR="RED"
>myhashtbl_takeout</FONT
>
でオーバーロードされていて、この関数は削除した要素を返すことを除いて <FONT
COLOR="RED"
>myhashtbl_remove</FONT
> と同じです。
次の数行のコードは、ハッシュテーブルに対するあまり一般的に使われない関数の使用例です:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN977"
></A
><PRE
CLASS="programlisting"
>//
val () = mymap.insert_any("a", 0)
val () = mymap.insert_any("b", 1)
val () = mymap.insert_any("c", 2)
val kxs = mymap.listize1((*void*))
val ((*void*)) = fprintln! (stdout_ref, "kxs = ", kxs)
val kxs = mymap.takeout_all((*void*))
val ((*void*)) = fprintln! (stdout_ref, "kxs = ", kxs)
//
val () = assertloc (mymap.size = 0)
//
</PRE
><P
></P
></DIV
>


ドット表記 <FONT
COLOR="RED"
>.insert_any</FONT
> は関数 <FONT
COLOR="RED"
>myhashtbl_insert_any</FONT
>
でオーバーロードされていて、この関数は、キーが使用中かどうかにかかわらず、与えられたキー/要素ペアを <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>常に</I
></SPAN
> 挿入します。
この関数は使用をさけるか、与えられたキーが使用中でない確証があるときのみ呼び出すべきでしょう。
そうでなければ、ハッシュテーブルが破損してしまうかもしれません。
ドット表記 <FONT
COLOR="RED"
>.listize1</FONT
> と <FONT
COLOR="RED"
>.takeout_all</FONT
> はそれぞれ2つの関数 <FONT
COLOR="RED"
>myhashtbl_listize1</FONT
> と <FONT
COLOR="RED"
>myhashtbl_takeout_all</FONT
> でオーバーロードされています。
これらは両方とも、与えられたハッシュテーブル中の全てのキー/要素ペアから成るリストを返します;
前者はハッシュテーブルを無変更で保持するのに対して、後者はハッシュテーブルを空にします。
最後に、与えられたハッシュテーブル内の全てのキー/要素ペアに対するイテレータのインターフェイスを次に示します:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN986"
></A
><PRE
CLASS="programlisting"
>//
extern
fun
myhashtbl_foreach_cloref
(
  tbl: myhashtbl
, fwork: (key, &#38;(itm) &#62;&#62; _) -&#60;cloref1&#62; void
) : void // end-of-function
//
</PRE
><P
></P
></DIV
>


例として、次のコードは与えられたハッシュテーブル内のキー/要素ペア全てを印字します:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN988"
></A
><PRE
CLASS="programlisting"
>//
val () =
myhashtbl_foreach_cloref
(
  mymap
, lam (k, x) =&#62; fprintln! (stdout_ref, "k=", k, " and ", "x=", x)
) (* myhashtbl_foreach_cloref *)
//
</PRE
><P
></P
></DIV
>


</P
><P
>&#13;この章で示したコード全体は
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/ATS2TUTORIAL/CODE/chap_hashtable.dats"
TARGET="_top"
>オンライン</A
>
から入手できます。
また、ハッシュテーブルを用いた symbol table の実装も
<A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/ATS2TUTORIAL/CODE/chap_hashtable2.dats"
TARGET="_top"
>オンライン</A
>
から入手できます。

</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c901.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c993.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>サイズを伴う永続化行列</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="p37.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>末尾再帰</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>