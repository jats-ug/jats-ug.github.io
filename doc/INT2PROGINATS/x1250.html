<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Example: Function Templates on Lists</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="ATSプログラミング入門"
HREF="index.html"><LINK
REL="UP"
TITLE="Parametric Polymorphism"
HREF="c1126.html"><LINK
REL="PREVIOUS"
TITLE="Polymorphic Datatypes"
HREF="x1215.html"><LINK
REL="NEXT"
TITLE="Example: Mergesort on Lists"
HREF="x1317.html"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>ATSプログラミング入門: </TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x1215.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 5. Parametric Polymorphism</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x1317.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="example_function_templates_on_lists"
>5.4. Example: Function Templates on Lists</A
></H1
><P
>&#13;In functional programming, lists are ubiquitous. We implement as follows
some commonly used function templates on lists. It should be noted that
these templates are all available in a library of ATS, where they may be
implemented in a significantly more efficient manner due to the use of
certain programming features (such as linear datatypes) that have not been
covered so far.
</P
><P
>&#13;Please find the entire code in this section plus some additional
code for testing <A
HREF="http://www.ats-lang.org/DOCUMENT/INT2PROGINATS/CODE/CHAPTER_POLYMORPHISM/listfun.dats"
TARGET="_top"
>on-line</A
>.
</P
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="list0_append"
>5.4.1. Appending: <FONT
COLOR="RED"
>list0_append</FONT
></A
></H2
><P
>&#13;Given two lists xs and ys of the type <FONT
COLOR="RED"
>list0(T)</FONT
> for some type T,
<FONT
COLOR="RED"
>list0_append(xs, ys)</FONT
> returns a list that is the concatenation
of xs and ys:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1261"
></A
><PRE
CLASS="programlisting"
>fun{
a:t@ype
} list0_append
(
  xs: list0 a
, ys: list0 a
) : list0 a =
(
case+ xs of
| list0_cons (x, xs) =&#62;
    list0_cons{a}(x, list0_append&#60;a&#62; (xs, ys))
| list0_nil ((*void*)) =&#62; ys
) (* end of [list0_append] *)
</PRE
><P
></P
></DIV
>


Clearly, this implementation of <FONT
COLOR="RED"
>list0_append</FONT
> is not
tail-recursive.
</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="list0_reverse_append"
>5.4.2. Reverse Appending: <FONT
COLOR="RED"
>list0_reverse_append</FONT
></A
></H2
><P
>&#13;Given two lists xs and ys of the type <FONT
COLOR="RED"
>list0(T)</FONT
> for some type T,
<FONT
COLOR="RED"
>list0_reverse_append(xs, ys)</FONT
> returns a list that is the
concatenation of the reverse of xs and ys:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1270"
></A
><PRE
CLASS="programlisting"
>fun{
a:t@ype
} list0_reverse_append
(
  xs: list0 a, ys: list0 a
) : list0 a =
(
case+ xs of
| list0_cons (x, xs) =&#62;
    list0_reverse_append&#60;a&#62; (xs, list0_cons{a}(x, ys))
| list0_nil () =&#62; ys
) (* end of [list0_reverse_append] *)
</PRE
><P
></P
></DIV
>


Clearly, this implementation of <FONT
COLOR="RED"
>list0_reverse_append</FONT
> is
tail-recursive.
</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="list0_reverse"
>5.4.3. Reversing: <FONT
COLOR="RED"
>list0_reverse</FONT
></A
></H2
><P
>&#13;Given a list xs, <FONT
COLOR="RED"
>list0_reverse(xs)</FONT
> returns the
reverse of xs:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1278"
></A
><PRE
CLASS="programlisting"
>fun{a:t@ype}
list0_reverse
  (xs: list0 a): list0 a = list0_reverse_append&#60;a&#62; (xs, list0_nil)
// end of [list0_reverse]
</PRE
><P
></P
></DIV
>

</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="list0_map"
>5.4.4. Mapping: <FONT
COLOR="RED"
>list0_map</FONT
></A
></H2
><P
>&#13;Given a list xs of the type <FONT
COLOR="RED"
>list0(T1)</FONT
> for some type T1 and a
closure function f of the type T1 -&#60;cloref1&#62; T2 for some type T2,
<FONT
COLOR="RED"
>list0_map(xs)</FONT
> returns a list ys of the type <FONT
COLOR="RED"
>list0(T2)</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1287"
></A
><PRE
CLASS="programlisting"
>fun
{a:t@ype}
{b:t@ype}
list0_map
(
  xs: list0 a, f: a -&#60;cloref1&#62; b
) : list0 b =
(
case+ xs of
| list0_cons (x, xs) =&#62;
    list0_cons{b}(f x, list0_map&#60;a&#62;&#60;b&#62; (xs, f))
| list0_nil ((*void*)) =&#62; list0_nil ()
) (* end of [list0_map] *)
</PRE
><P
></P
></DIV
>


The length of ys equals that of xs and each element y in ys equals f(x),
where x is the corresponding element in xs.  Clearly, this implementation
of <FONT
COLOR="RED"
>list0_map</FONT
> is not tail-recursive.
</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="list0_zip"
>5.4.5. Zipping: <FONT
COLOR="RED"
>list0_zip</FONT
></A
></H2
><P
>\ Given two lists xs and ys of the types <FONT
COLOR="RED"
>list0(T1)</FONT
> and
<FONT
COLOR="RED"
>list0(T2)</FONT
> for some types T1 and T2, respectively,
<FONT
COLOR="RED"
>list0_zip(xs, ys)</FONT
> returns a list zs of the type <FONT
COLOR="RED"
>list0 @(T1, T2)</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1298"
></A
><PRE
CLASS="programlisting"
>fun{
a,b:t@ype
} list0_zip
(
  xs: list0 a
, ys: list0 b
) : list0 @(a, b) = let
  typedef ab = @(a, b)
in
//
case+ (xs, ys) of
| (list0_cons (x, xs),
   list0_cons (y, ys)) =&#62;
  (
    list0_cons{ab}((x, y), list0_zip&#60;a,b&#62; (xs, ys))
  )
| (_, _) =&#62; list0_nil ()
//
end // end of [list0_zip]
</PRE
><P
></P
></DIV
>


The length of zs is the minimum of the lengths of xs and ys and each
element z in zs @(x, y), where x and y are the corresponding elements in xs
and ys, respectively.  Clearly, this implementation of <FONT
COLOR="RED"
>list0_zip</FONT
>
is not tail-recursive.
</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="list0_zipwith"
>5.4.6. Zipping with: <FONT
COLOR="RED"
>list0_zipwith</FONT
></A
></H2
><P
>&#13;Given two lists xs and ys of the types <FONT
COLOR="RED"
>list0(T1)</FONT
> and
<FONT
COLOR="RED"
>list0(T2)</FONT
> for some types T1 and T2, respectively, and a closure
function f of the type (T1, T2) -&#60;cloref1&#62; T3 for some type T3,
<FONT
COLOR="RED"
>list0_zipwith(xs, ys, f)</FONT
> returns a list zs of the type
<FONT
COLOR="RED"
>list0(T3)</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1309"
></A
><PRE
CLASS="programlisting"
>fun
{a,b:t@ype}
{c:t@ype}
list0_zipwith
(
  xs: list0 a
, ys: list0 b
, f: (a, b) -&#60;cloref1&#62; c
) : list0 c =
(
case+ (xs, ys) of
| (list0_cons (x, xs),
   list0_cons (y, ys)) =&#62;
  (
    list0_cons{c}(f (x, y), list0_zipwith&#60;a,b&#62;&#60;c&#62; (xs, ys, f))
  )
| (_, _) =&#62; list0_nil ()
) (* end of [list0_zipwith] *)
</PRE
><P
></P
></DIV
>


The length of zs is the minimum of the lengths of xs and ys and each
element z in zs is f(x, y), where x and y are the corresponding elements in
xs and ys, respectively.  Clearly, this implementation of
<FONT
COLOR="RED"
>list0_zipwith</FONT
> is not tail-recursive.  Note that
<FONT
COLOR="RED"
>list0_zipwith</FONT
> behaves exactly like <FONT
COLOR="RED"
>list0_zip</FONT
> if its
third argument <FONT
COLOR="RED"
>f</FONT
> is replaced with <FONT
COLOR="RED"
>lam (x, y) =&#62; @(x, y)</FONT
>.
This function template is also named <FONT
COLOR="RED"
>list0_map2</FONT
> for the obvious
reason.
</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x1215.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x1317.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Polymorphic Datatypes</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c1126.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Example: Mergesort on Lists</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>