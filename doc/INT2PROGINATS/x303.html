<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>タプルとタプル型</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="ATSプログラミング入門"
HREF="index.html"><LINK
REL="UP"
TITLE="プログラミングの構成要素"
HREF="c100.html"><LINK
REL="PREVIOUS"
TITLE="プリミティブ型"
HREF="x245.html"><LINK
REL="NEXT"
TITLE="Records and Record Types"
HREF="x323.html"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>ATSプログラミング入門: </TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x245.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 2. プログラミングの構成要素</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x323.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="tuples_and_tuple_types"
>2.7. タプルとタプル型</A
></H1
><P
>&#13;2つの型T1とT2が与えられた時、タプル型である (T1, T2) を作ることがきます。
これは @(T1, T2) のように書くこともできます。
exp1とexp2がそれぞれT1とT2型の式であるとしましょう。
すると式 (exp1, exp2) または @(exp1, exp2) は (T1, T2) 型のタプルであることになります。
さらに、より多くの要素を持つタプルとタプル型を作ることもできます。
タプルにタプル型を割り振るために、
そのタプルとそのタプル型は持っている要素が同じ数でなければなりません。 
</P
><P
>&#13;タプルの式を評価する時、その要素すべてを <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>連続して(sequentially)</I
></SPAN
> 評価します。
その式がn個の要素を持っていたと想像してみましょう。
するとその式の値は、
要素の順に列挙されたn個の要素の値によって構成されているタプルであることになります。 
</P
><P
>&#13;2以上の長さnのタプルは、フィールド名は0からn-1までの範囲を取る単なるレコードです。
タプル型 (T1, T2) の式 exp が与えられた時、
(exp).0 や (exp).1 のような式を作ることができます。
これらはそれぞれT1型とT2型を取ります。
式expは必ずしもタプルの式である必要はないことに注意してください。
例えば、expは名前や関数適用であってもかまいません。
もしexpを評価して2つの値を持つタプルになった場合、
exp.0は1番目の値に評価され、exp.1は二番目の値に評価されることになります。
expのタプル型がより多くの要素を持っていた場合、
当然このような式は一般化できます。 
</P
><P
>&#13;In the following example, we first construct a tuple of length 3 and then
introduce bindings between 3 names and all of the 3 components of the
tuple:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN310"
></A
><PRE
CLASS="programlisting"
>&#13;val xyz = ('A', 1, 2.0)
val x = xyz.0 and y = xyz.1 and z = xyz.2
</PRE
><P
></P
></DIV
>

Note that the constructed tuple can be assigned the tuple type
<FONT
COLOR="RED"
>(char, int, double)</FONT
>. Another method for selecting components in
a given tuple is based on pattern matching, which is employed in the
following example:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN313"
></A
><PRE
CLASS="programlisting"
>&#13;val xyz = ('A', 1, 2.0)
val (x, y, z) = xyz // x = 'A'; y = 1; z = 2.0
</PRE
><P
></P
></DIV
>

Note that <FONT
COLOR="RED"
>(x, y, z)</FONT
> is a pattern that can match any tuples of
exact 3 components. I will say more about pattern matching elsewhere.
</P
><P
>&#13;The tuples introduced above are often referred to as flat tuples, native
tuples or unboxed tuples. There is another kind of tuples supported in ATS,
which are called boxed tuples. A boxed tuple is essentially a pointer
pointing to some heap location where a flat tuple is stored.
</P
><P
>&#13;Assume that exp1 and exp2 are two expressions of the types T1 and T2,
respectively. Then the expression '(exp1, exp2), refers to a tuple of the
tuple type '(T1, T2). Accordingly, we can form boxed tuples and boxed tuple
types of fewer or more components. What should be noted immediately is that
every boxed tuple is of the size of a pointer, and can thus be stored in
any place where a pointer can. Using boxed tuples is rather similar to
using unboxed ones. For instance, the meaning of the following code should
be evident:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN318"
></A
><PRE
CLASS="programlisting"
>&#13;val xyz = '( 'A', 1, 2.0 )
val x = xyz.0 and y = xyz.1 and z = xyz.2
</PRE
><P
></P
></DIV
>

Note that a space is needed between <FONT
COLOR="RED"
>'(</FONT
> and <FONT
COLOR="RED"
>'A'</FONT
>
for otherwise the current parser (for ATS/Postiats) would be confused.
</P
><P
>&#13;Given the availability of flat and boxed tuples, one naturally wants to
know whether there is a simple way to determine which kind is preferred
over the other. Unfortunately, there is no simple way to do this as far as
I can tell. In order to be certain, some kind of profiling is often
needed. However, if we want to run code with no support of garbage
collection (GC), then we should definitely avoid using boxed tuples.
</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x245.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x323.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>プリミティブ型</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c100.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Records and Record Types</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>